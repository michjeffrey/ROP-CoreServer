"use strict";
/**
 * Copyright 2022 Angus Fenying <fenying@litert.org>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.createJavaScriptLanguageBuilder = void 0;
class JavaScriptLanguage {
    switchCase(expr, cases) {
        return `switch (${expr}) { ${cases.join('')} }`;
    }
    caseIf(cond, expr) {
        return `${cond.map((x) => `case ${x}:`).join(' ')} { ${expr} break; }`;
    }
    caseDefault(expr) {
        return `default: { ${expr} break; }`;
    }
    lowerCase(a) {
        return `${a}.toLowerCase()`;
    }
    array(v) {
        return JSON.stringify(v);
    }
    arrayInSet(a, b) {
        return `(function(a, b) {
            return Array.from(new Set(a.concat(b))).length === b.length;
        })(${a}, ${b})`;
    }
    instr(expr, match) {
        return `${expr}.includes(${match})`;
    }
    call(fnName, ...args) {
        return `${fnName}(${args.join(',')})`;
    }
    startsWith(expr, match) {
        return `${expr}.startsWith(${match})`;
    }
    endsWith(expr, match) {
        return `${expr}.endsWith(${match})`;
    }
    varName(index) {
        return `v_${index}`;
    }
    _dereplicate(conds) {
        return Array.from(new Set(conds));
    }
    ifElseOp(cond, a, b) {
        return `(${cond}) ? ${a} : ${b}`;
    }
    or(conditions) {
        if (conditions.length === 1) {
            return conditions[0];
        }
        if (conditions.includes('true')) {
            return 'true';
        }
        conditions = this._dereplicate(conditions.filter((x) => x !== 'false'));
        if (!conditions.length) {
            return 'true';
        }
        return `${conditions.map((x) => `(${x})`).join(' || ')}`;
    }
    and(conditions) {
        if (conditions.length === 1) {
            return conditions[0];
        }
        if (conditions.includes('false')) {
            return 'false';
        }
        conditions = this._dereplicate(conditions.filter((x) => x !== 'true'));
        if (!conditions.length) {
            return 'true';
        }
        return `${conditions.map((x) => `(${x})`).join(' && ')}`;
    }
    eq(a, b) {
        return `${a} === ${b}`;
    }
    ne(a, b) {
        return `${a} !== ${b}`;
    }
    gt(a, b) {
        return `${a} > ${b}`;
    }
    gte(a, b) {
        return `${a} >= ${b}`;
    }
    lt(a, b) {
        return `${a} < ${b}`;
    }
    lte(a, b) {
        return `${a} <= ${b}`;
    }
    not(a) {
        return `!(${a})`;
    }
    literal(val) {
        return JSON.stringify(val);
    }
    modOf(a, b) {
        return `${a} % ${b}`;
    }
    matchRegExp(expr, regExp) {
        const m = /^\/(.+)\/([a-z]*)$/i.exec(regExp);
        if (m) {
            return `/${m[1]}/${m[2] || ''}.test(${expr})`;
        }
        return `/${regExp}/.test(${expr})`;
    }
    isNull(vn, positive = true) {
        return `${vn} ${this._equal(positive)} null`;
    }
    isUndefined(vn, positive = true) {
        return `${vn} ${this._equal(positive)} undefined`;
    }
    _equal(positive = true) {
        return positive ? '===' : '!==';
    }
    _not(positive = true) {
        return positive ? '' : '!';
    }
    isString(vn, positive = true) {
        return `typeof ${vn} ${this._equal(positive)} "string"`;
    }
    isStrucutre(vn, positive = true) {
        return positive ?
            `(typeof ${vn} === "object" && ${vn} !== null && !Array.isArray(${vn}))` :
            `(typeof ${vn} !== "object" || ${vn} === null || Array.isArray(${vn}))`;
    }
    isInteger(vn, positive = true) {
        return `${this._not(positive)}Number.isInteger(${vn})`;
    }
    isNumber(vn, positive = true) {
        return positive ?
            `typeof ${vn} === "number" && Number.isFinite(${vn}) && !Number.isNaN(${vn})` :
            `typeof ${vn} !== "number" || !Number.isFinite(${vn}) || Number.isNaN(${vn})`;
    }
    isNumeric(vn, positive = true) {
        return positive ? this.or([
            this.isNumber(vn, true),
            this.and([
                this.isString(vn, true),
                this.matchRegExp(vn, '^[+-]?\\d+(\\.\\d+)?$')
            ])
        ]) : this.and([
            this.isNumber(vn, false),
            this.or([
                this.isString(vn, false),
                this.not(this.matchRegExp(vn, '^[+-]?\\d+(\\.\\d+)?$'))
            ])
        ]);
    }
    isArray(vn, positive = true) {
        return `${this._not(positive)}Array.isArray(${vn})`;
    }
    isBoolean(vn, positive = true) {
        return `typeof ${vn} ${this._equal(positive)} "boolean"`;
    }
    arrayLength(vn) {
        return `${vn}.length`;
    }
    stringLength(vn) {
        return `${vn}.length`;
    }
    keys(vn) {
        return `Object.keys(${vn})`;
    }
    forEach(arrVar, elVar, iterVar, body) {
        return `for (let ${elVar} = 0; ${elVar} < ${arrVar}.length; ${elVar}++) {
            const ${iterVar} = ${arrVar}[${elVar}];
            ${body}
        }`;
    }
    series(statements) {
        return statements.map((s) => s.endsWith(';') ? s : `${s};`).join('');
    }
    ifThen(condition, ifBody, elseBody) {
        if (elseBody) {
            return `if (${condition}) {
                ${ifBody}
            } else {
                ${elseBody}
            }`;
        }
        return `if (${condition}) { ${ifBody} }`;
    }
    forIn(o, k, i, body) {
        return `for (const ${k} in ${o}) { const ${i} = ${o}[${k}]; ${body} }`;
    }
    fieldIndex(o, k) {
        return `${o}[${k}]`;
    }
    str2Int(expr) {
        return `parseInt(${expr})`;
    }
    str2Float(expr) {
        return `parseFloat(${expr})`;
    }
    str2Bool(expr) {
        return `(${expr} === "true" ? true : (${expr} === "false" ? false : null))`;
    }
    arraySlice(arrayName, start, end) {
        if (end !== undefined) {
            return `${arrayName}.slice(${start}, ${end})`;
        }
        return `${arrayName}.slice(${start})`;
    }
    arrayIndex(a, i) {
        return `${a}[${i}]`;
    }
    get literalFalse() {
        return 'false';
    }
    get literalTrue() {
        return 'true';
    }
    get maxSafeInteger() {
        return '0X1FFFFFFFFFFFFF';
    }
    get minSafeInteger() {
        return '-0X1FFFFFFFFFFFFF';
    }
    isTrueValue(vn) {
        return `!!${vn}`;
    }
    isFalseValue(vn) {
        return `!${vn}`;
    }
    returnValue(vn) {
        return `return ${vn};`;
    }
    closure(params, args, body) {
        return `(function(${params.join(', ')}) {
            ${body}
        })(${args.join(', ')})`;
    }
    escape(str) {
        return str.replace(/(['"])/g, '\\$1').replace(/\n/g, '\\n').replace(/\r/g, '\\r');
    }
    stringTemplateVar(varExpr) {
        return `"\${${varExpr}.replace(/(['"])/g, '\\\\$1').replace(/\\n/g, '\\\\n').replace(/\\r/g, '\\\\r')}"`;
    }
    numberTemplateVar(varExpr) {
        return `\${${varExpr}}`;
    }
    addTrace(vTrace, vTraceStack, path, negative = false) {
        if (negative) {
            return `(${vTrace}.push(\`\${${vTraceStack}}${path}\`), true)`;
        }
        return `(${vTrace}.push(\`\${${vTraceStack}}${path}\`), false)`;
    }
    add(a, b) {
        return `${a} + ${b}`;
    }
    orAddTrace(expr, vTrace, vTraceStack, path, negative = false) {
        if (negative) {
            return `((${expr}) && (${vTrace}.push(\`\${${vTraceStack}}${path}\`), true))`;
        }
        return `((${expr}) || (${vTrace}.push(\`\${${vTraceStack}}${path}\`), false))`;
    }
}
/**
 * Create a language builder object for JavaScript.
 */
function createJavaScriptLanguageBuilder() {
    return new JavaScriptLanguage();
}
exports.createJavaScriptLanguageBuilder = createJavaScriptLanguageBuilder;
//# sourceMappingURL=JavaScript.js.map