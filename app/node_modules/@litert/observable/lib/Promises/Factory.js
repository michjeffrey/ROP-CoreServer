"use strict";
/**
 * Copyright 2020 Angus.Fenying <fenying@litert.org>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.createPromiseFactory = void 0;
/* eslint-disable @typescript-eslint/unbound-method */
const C = require("./Common");
const E = require("./Errors");
class TimeoutPromise {
    constructor(timeout, _slots, id = C.ANONYMOUS_PROMISE, _msger, _target, _issuer) {
        this._slots = _slots;
        this.id = id;
        this._msger = _msger;
        this._target = _target;
        this._issuer = _issuer;
        this.promise = new Promise((resolve, reject) => {
            this._resolve = resolve;
            this._reject = reject;
        });
        this.expiringAt = Date.now() + timeout;
        this._timer = setTimeout(() => {
            delete this._timer;
            if (this.id !== C.ANONYMOUS_PROMISE) {
                delete this._slots[this.id];
            }
            this._reject(new E.E_TIMEOUT());
        }, timeout);
        this.reject = this.reject.bind(this);
        this.resolve = this.resolve.bind(this);
    }
    get timeout() {
        return !this._timer;
    }
    reject(e) {
        var _a;
        if (!this._timer) {
            (_a = this._msger) === null || _a === void 0 ? void 0 : _a.publish('promise:timeout_result', false, e, this._target, this._issuer);
            return;
        }
        clearTimeout(this._timer);
        delete this._timer;
        if (this.id !== C.ANONYMOUS_PROMISE) {
            delete this._slots[this.id];
        }
        this._reject(e);
    }
    resolve(e) {
        var _a;
        if (!this._timer) {
            (_a = this._msger) === null || _a === void 0 ? void 0 : _a.publish('promise:timeout_result', true, e, this._target, this._issuer);
            return;
        }
        clearTimeout(this._timer);
        delete this._timer;
        if (this.id !== C.ANONYMOUS_PROMISE) {
            delete this._slots[this.id];
        }
        this._resolve(e);
    }
}
class PromiseFactory {
    constructor(_msger) {
        this._msger = _msger;
        this._uniquePromises = {};
    }
    findPromise(id) {
        return this._uniquePromises[id] || null;
    }
    createPromise(opts) {
        var _a;
        const ret = { id: (_a = opts === null || opts === void 0 ? void 0 : opts.id) !== null && _a !== void 0 ? _a : C.ANONYMOUS_PROMISE };
        if (opts === null || opts === void 0 ? void 0 : opts.id) {
            const id = opts.id || C.ANONYMOUS_PROMISE;
            if (this._uniquePromises[id]) {
                throw new E.E_DUP_PROMISE({ metadata: { id } });
            }
            ret.promise = new Promise((resolve, reject) => {
                ret.reject = (e) => {
                    delete this._uniquePromises[id];
                    reject(e);
                };
                ret.resolve = (v) => {
                    delete this._uniquePromises[id];
                    resolve(v);
                };
            });
            this._uniquePromises[id] = ret;
            return ret;
        }
        ret.promise = new Promise((resolve, reject) => {
            ret.reject = reject;
            ret.resolve = resolve;
        });
        return ret;
    }
    createTimeoutPromise(opts) {
        const ret = new TimeoutPromise(opts.timeout, this._uniquePromises, opts.id, this._msger, opts.target, opts.issuer);
        if (opts.id) {
            this._uniquePromises[opts.id] = ret;
        }
        return ret;
    }
}
function createPromiseFactory(messenger) {
    return new PromiseFactory(messenger);
}
exports.createPromiseFactory = createPromiseFactory;
//# sourceMappingURL=Factory.js.map