"use strict";
/**
 * Copyright 2020 Angus.Fenying <fenying@litert.org>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.createLocalMessenger = void 0;
const E = require("./Errors");
const Events = require("../Events");
class LocalMessenger extends Events.EventEmitter {
    constructor() {
        super();
        this._subjects = {};
    }
    subscribe(subject, key, callback) {
        if (!Array.isArray(subject)) {
            subject = [subject];
        }
        for (const s of subject) {
            if (!this._subjects[s]) {
                this._subjects[s] = {};
            }
            if (this._subjects[s][key]) {
                throw new E.E_DUP_SUBSCRIBER({ metadata: { subject: s, key } });
            }
            this._subjects[s][key] = callback;
            this.emit('new_subscriber', s, key);
        }
        return this;
    }
    unsubscribe(subject, key) {
        if (!this._subjects[subject]) {
            return this;
        }
        delete this._subjects[subject][key];
        return this;
    }
    unsubscribeAll(subject) {
        delete this._subjects[subject];
        return this;
    }
    publish(subject, ...args) {
        this.publishBlocking(subject, ...args).catch(() => null);
    }
    async publishBlocking(subject, ...args) {
        const callbacks = this._subjects[subject];
        if (!callbacks) {
            this.emit('missing_subscriber', subject, ...args);
            return;
        }
        for (const key in callbacks) {
            try {
                const t = callbacks[key](...args);
                if (t instanceof Promise) {
                    await t;
                }
            }
            catch (e) {
                this.emit('subscriber_error', e, subject, key, ...args);
                continue;
            }
        }
    }
    getSubjectList() {
        return [
            ...Object.getOwnPropertySymbols(this._subjects),
            ...Object.getOwnPropertyNames(this._subjects)
        ];
    }
    getSubscriberList(subject) {
        return [
            ...Object.getOwnPropertySymbols(this._subjects[subject] || {}),
            ...Object.getOwnPropertyNames(this._subjects[subject] || {})
        ];
    }
}
function createLocalMessenger() {
    return new LocalMessenger();
}
exports.createLocalMessenger = createLocalMessenger;
//# sourceMappingURL=LocalMessenger.js.map