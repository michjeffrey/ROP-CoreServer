"use strict";
/**
 * Copyright 2020 Angus.Fenying <fenying@litert.org>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.EventEmitter = void 0;
const Errors = require("./Errors");
const PRIV_PROP_EVENT_SLOTS = Symbol('events:slots');
const PRIV_PROP_CONFIG = Symbol('events:config');
class ListenerInfo {
    constructor(callback, once) {
        this.callback = callback;
        this.once = once;
    }
}
const DEFAULT_CONFIGURATION = {
    continueOnError: false,
    interruptable: false,
    maxListeners: 10
};
class EventInfo {
    constructor(config) {
        this.config = config;
        this.listeners = [];
    }
}
class EventEmitter {
    constructor(config) {
        this[PRIV_PROP_EVENT_SLOTS] = {};
        this[PRIV_PROP_CONFIG] = Object.assign(Object.assign({}, DEFAULT_CONFIGURATION), config);
    }
    addListener(event, callback) {
        return this.on(event, callback);
    }
    on(event, callback) {
        let ev = this[PRIV_PROP_EVENT_SLOTS][event];
        if (!ev) {
            ev = this[PRIV_PROP_EVENT_SLOTS][event] = new EventInfo(this[PRIV_PROP_CONFIG]);
        }
        if (ev.config.maxListeners === ev.listeners.length) {
            throw new Errors.E_EXCEED_MAX_LISTENERS();
        }
        ev.listeners.push(new ListenerInfo(callback, false));
        return this;
    }
    addOnceListener(event, callback) {
        return this.once(event, callback);
    }
    once(event, callback) {
        let ev = this[PRIV_PROP_EVENT_SLOTS][event];
        if (!ev) {
            ev = this[PRIV_PROP_EVENT_SLOTS][event] = new EventInfo(this[PRIV_PROP_CONFIG]);
        }
        if (ev.config.maxListeners === ev.listeners.length) {
            throw new Errors.E_EXCEED_MAX_LISTENERS();
        }
        ev.listeners.push(new ListenerInfo(callback, true));
        return this;
    }
    eventNames() {
        return Object.keys(this[PRIV_PROP_EVENT_SLOTS]);
    }
    hasListener(event, callback) {
        const ev = this[PRIV_PROP_EVENT_SLOTS][event];
        if (!ev) {
            return false;
        }
        return ev.listeners.filter((x) => x.callback === callback).length > 0;
    }
    listeners(event) {
        const ev = this[PRIV_PROP_EVENT_SLOTS][event];
        return ev ? ev.listeners.map((x) => x.callback) : [];
    }
    listenerCount(event) {
        const ev = this[PRIV_PROP_EVENT_SLOTS][event];
        return ev ? ev.listeners.length : 0;
    }
    off(event, callback) {
        const ev = this[PRIV_PROP_EVENT_SLOTS][event];
        if (!ev) {
            return 0;
        }
        if (callback) {
            for (let i = 0; i < ev.listeners.length; i++) {
                if (ev.listeners[i].callback === callback) {
                    ev.listeners.splice(i--, 1);
                }
            }
        }
        return ev.listeners.splice(0).length;
    }
    removeListener(event, callback) {
        return this.off(event, callback);
    }
    configEvent(...args) {
        if (args.length === 2) {
            const ev = this[PRIV_PROP_EVENT_SLOTS][args[0]];
            if (ev) {
                ev.config = Object.assign(Object.assign({}, ev.config), args[1]);
            }
            else {
                this[PRIV_PROP_EVENT_SLOTS][args[0]] = new EventInfo(Object.assign(Object.assign({}, this[PRIV_PROP_CONFIG]), args[1]));
            }
        }
        else {
            this[PRIV_PROP_CONFIG] = Object.assign(Object.assign({}, this[PRIV_PROP_CONFIG]), args[0]);
        }
        return this;
    }
    emit(event, ...args) {
        const ev = this[PRIV_PROP_EVENT_SLOTS][event];
        if (!ev || !ev.listeners.length) {
            return false;
        }
        const INTERRUPTABLE = ev.config.interruptable;
        const CONTINUE_ON_ERROR = ev.config.continueOnError;
        for (let i = 0; i < ev.listeners.length; i++) {
            const listener = ev.listeners[i];
            try {
                const ret = listener.callback.apply(this, args);
                if (INTERRUPTABLE && ret === false) {
                    return true;
                }
            }
            catch (e) {
                if (event === 'error') {
                    throw e;
                }
                // @ts-ignore
                this.emit('error', e);
                if (!CONTINUE_ON_ERROR) {
                    return true;
                }
            }
            finally {
                if (listener.once) {
                    ev.listeners.splice(i--, 1);
                }
            }
        }
        return true;
    }
}
exports.EventEmitter = EventEmitter;
//# sourceMappingURL=EventEmitter.js.map