"use strict";
/**
 * Copyright 2021 Angus.Fenying <fenying@litert.org>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.createReflectManager = void 0;
require("reflect-metadata");
const decorator_1 = require("@litert/decorator");
const privData = new WeakMap();
function prepareClass(rm, target) {
    const $data = privData.get(rm);
    if (!$data.classes.has(target)) {
        $data.classes.set(target, {
            'data': new Map(),
            'methods': new Map(),
            'properties': new Map(),
            'staticMethods': new Map(),
            'staticProperties': new Map(),
            'parameters': new Map()
        });
    }
    return $data.classes.get(target);
}
function prepareCtorParam(rm, target, index) {
    const $data = prepareClass(rm, target);
    if (!$data.parameters.has(index)) {
        $data.parameters.set(index, new Map());
    }
    return $data.parameters.get(index);
}
function prepareMethod(rm, target, name) {
    const $data = prepareClass(rm, target);
    if (!$data.methods.has(name)) {
        $data.methods.set(name, {
            'data': new Map(),
            'parameters': new Map()
        });
    }
    return $data.methods.get(name);
}
function prepareMethodParam(rm, target, name, index) {
    const $data = prepareMethod(rm, target, name);
    if (!$data.parameters.has(index)) {
        $data.parameters.set(index, new Map());
    }
    return $data.parameters.get(index);
}
function prepareProperty(rm, target, name) {
    const $data = prepareClass(rm, target);
    if (!$data.properties.has(name)) {
        $data.properties.set(name, new Map());
    }
    return $data.properties.get(name);
}
function prepareStaticMethod(rm, target, name) {
    const $data = prepareClass(rm, target);
    if (!$data.staticMethods.has(name)) {
        $data.staticMethods.set(name, {
            'data': new Map(),
            'parameters': new Map()
        });
    }
    return $data.staticMethods.get(name);
}
function prepareStaticMethodParam(rm, target, name, index) {
    const $data = prepareStaticMethod(rm, target, name);
    if (!$data.parameters.has(index)) {
        $data.parameters.set(index, new Map());
    }
    return $data.parameters.get(index);
}
function prepareStaticProperty(rm, target, name) {
    const $data = prepareClass(rm, target);
    if (!$data.staticProperties.has(name)) {
        $data.staticProperties.set(name, new Map());
    }
    return $data.staticProperties.get(name);
}
function getMetadataDefinition(mgr, key) {
    const $data = privData.get(mgr);
    if (!$data.metadata.has(key)) {
        return {
            'onDuplicated': 'overwrite'
        };
    }
    return $data.metadata.get(key);
}
function metadataKeyToString(k) {
    return typeof k === 'symbol' ? k.description : k;
}
function setMetadata(mgr, vessel, key, value) {
    var _a;
    const opts = getMetadataDefinition(mgr, key);
    if (opts.validator && !opts.validator(value)) {
        throw new TypeError(`Invalid value for metadata "${metadataKeyToString(key)}".`);
    }
    let slot = (_a = vessel.get(key)) !== null && _a !== void 0 ? _a : [];
    if (opts.wrapper) {
        value = opts.wrapper(value);
    }
    if (slot.length) {
        switch (opts.onDuplicated) {
            case 'overwrite':
                slot[0] = value;
                break;
            case 'multiple':
                slot.push(value);
                break;
            case 'reject':
                throw new Error(`Cat not edit a existing metadata "${metadataKeyToString(key)}".`);
            default:
                throw new Error(`Failed to update the metadata "${metadataKeyToString(key)}".`);
        }
    }
    else {
        slot.push(value);
    }
    vessel.set(key, slot);
}
function getMetadata(mgr, vessel, key) {
    var _a;
    const opts = getMetadataDefinition(mgr, key);
    let slot = (_a = vessel.get(key)) !== null && _a !== void 0 ? _a : [];
    if (slot.length) {
        switch (opts.onDuplicated) {
            case 'overwrite':
            case 'reject':
                return slot[0];
            case 'multiple':
                return slot;
            default:
                throw new Error(`Failed to get the metadata "${metadataKeyToString(key)}".`);
        }
    }
    return undefined;
}
class ReflectManager {
    constructor() {
        privData.set(this, {
            'classes': new WeakMap(),
            'metadata': new Map()
        });
    }
    setClassMetadata(target, key, value) {
        setMetadata(this, prepareClass(this, target).data, key, value);
    }
    setConstructorParameterMetadata(target, index, key, value) {
        setMetadata(this, prepareCtorParam(this, target, index), key, value);
    }
    setMethodMetadata(target, name, key, value) {
        setMetadata(this, prepareMethod(this, target, name).data, key, value);
    }
    setStaticMethodMetadata(target, name, key, value) {
        setMetadata(this, prepareStaticMethod(this, target, name).data, key, value);
    }
    setAccessorMetadata(target, name, key, value) {
        setMetadata(this, prepareProperty(this, target, name), key, value);
    }
    setStaticAccessorMetadata(target, name, key, value) {
        setMetadata(this, prepareStaticProperty(this, target, name), key, value);
    }
    setPropertyMetadata(target, name, key, value) {
        setMetadata(this, prepareProperty(this, target, name), key, value);
    }
    setStaticPropertyMetadata(target, name, key, value) {
        setMetadata(this, prepareStaticProperty(this, target, name), key, value);
    }
    setMethodParameterMetadata(target, name, index, key, value) {
        setMetadata(this, prepareMethodParam(this, target, name, index), key, value);
    }
    setStaticMethodParameterMetadata(target, name, index, key, value) {
        setMetadata(this, prepareStaticMethodParam(this, target, name, index), key, value);
    }
    getClassMetadata(target, key) {
        return getMetadata(this, prepareClass(this, target).data, key);
    }
    getConstructorParameterMetadata(target, index, key) {
        return getMetadata(this, prepareCtorParam(this, target, index), key);
    }
    getMethodMetadata(target, name, key) {
        return getMetadata(this, prepareMethod(this, target, name).data, key);
    }
    getStaticMethodMetadata(target, name, key) {
        return getMetadata(this, prepareStaticMethod(this, target, name).data, key);
    }
    getAccessorMetadata(target, name, key) {
        return getMetadata(this, prepareProperty(this, target, name), key);
    }
    getStaticAccessorMetadata(target, name, key) {
        return getMetadata(this, prepareStaticProperty(this, target, name), key);
    }
    getPropertyMetadata(target, name, key) {
        return getMetadata(this, prepareProperty(this, target, name), key);
    }
    getStaticPropertyMetadata(target, name, key) {
        return getMetadata(this, prepareStaticProperty(this, target, name), key);
    }
    getMethodParameterMetadata(target, name, index, key) {
        return getMetadata(this, prepareMethodParam(this, target, name, index), key);
    }
    getStaticMethodParameterMetadata(target, name, index, key) {
        return getMetadata(this, prepareStaticMethodParam(this, target, name, index), key);
    }
    getClassMetadataKeys(target) {
        return Array.from(prepareClass(this, target).data.keys());
    }
    getConstructorParameterMetadataKeys(target, index) {
        return Array.from(prepareCtorParam(this, target, index).keys());
    }
    getMethodMetadataKeys(target, name) {
        return Array.from(prepareMethod(this, target, name).data.keys());
    }
    getStaticMethodMetadataKeys(target, name) {
        return Array.from(prepareStaticMethod(this, target, name).data.keys());
    }
    getAccessorMetadataKeys(target, name) {
        return Array.from(prepareProperty(this, target, name).keys());
    }
    getStaticAccessorMetadataKeys(target, name) {
        return Array.from(prepareStaticProperty(this, target, name).keys());
    }
    getPropertyMetadataKeys(target, name) {
        return Array.from(prepareProperty(this, target, name).keys());
    }
    getStaticPropertyMetadataKeys(target, name) {
        return Array.from(prepareStaticProperty(this, target, name).keys());
    }
    getMethodParameterMetadataKeys(target, name, index) {
        return Array.from(prepareMethodParam(this, target, name, index).keys());
    }
    getStaticMethodParameterMetadataKeys(target, name, index) {
        return Array.from(prepareStaticMethodParam(this, target, name, index).keys());
    }
    deleteClassMetadata(target, key) {
        prepareClass(this, target).data.delete(key);
    }
    deleteConstructorParameterMetadata(target, index, key) {
        prepareCtorParam(this, target, index).delete(key);
    }
    deleteMethodMetadata(target, name, key) {
        prepareMethod(this, target, name).data.delete(key);
    }
    deleteStaticMethodMetadata(target, name, key) {
        prepareStaticMethod(this, target, name).data.delete(key);
    }
    deleteAccessorMetadata(target, name, key) {
        prepareProperty(this, target, name).delete(key);
    }
    deleteStaticAccessorMetadata(target, name, key) {
        prepareStaticProperty(this, target, name).delete(key);
    }
    deletePropertyMetadata(target, name, key) {
        prepareProperty(this, target, name).delete(key);
    }
    deleteStaticPropertyMetadata(target, name, key) {
        prepareStaticProperty(this, target, name).delete(key);
    }
    deleteMethodParameterMetadata(target, name, index, key) {
        prepareMethodParam(this, target, name, index).delete(key);
    }
    deleteStaticMethodParameterMetadata(target, name, index, key) {
        prepareStaticMethodParam(this, target, name, index).delete(key);
    }
    metadata(key, value) {
        return this.createGeneralMetadataDecorator(key, value);
    }
    createAccessorMetadataDecorator(key, value) {
        return decorator_1.default.createAccessorDecorator((proto, name) => {
            this.setAccessorMetadata(proto.constructor, name, key, value);
        });
    }
    createClassMetadataDecorator(key, value) {
        return decorator_1.default.createClassDecorator((ctor) => {
            this.setClassMetadata(ctor, key, value);
        });
    }
    createConstructorParameterMetadataDecorator(key, value) {
        return decorator_1.default.createConstructorParameterDecorator((ctor, index) => {
            this.setConstructorParameterMetadata(ctor, index, key, value);
        });
    }
    createGeneralMetadataDecorator(key, value, positions) {
        if (!(positions === null || positions === void 0 ? void 0 : positions.length)) {
            positions = [
                'accessor', 'class', 'ctorParameter', 'method',
                'methodParameter', 'property', 'staticAccessor', 'staticMethod',
                'staticMethodParameter', 'staticProperty'
            ];
        }
        const decSet = {};
        for (const k of positions) {
            switch (k) {
                case 'accessor':
                    decSet.accessor = (proto, name) => {
                        this.setAccessorMetadata(proto.constructor, name, key, value);
                    };
                    break;
                case 'class':
                    decSet.class = (ctor) => {
                        this.setClassMetadata(ctor, key, value);
                    };
                    break;
                case 'ctorParameter':
                    decSet.ctorParameter = (ctor, i) => {
                        this.setConstructorParameterMetadata(ctor, i, key, value);
                    };
                    break;
                case 'method':
                    decSet.method = (proto, n) => {
                        this.setMethodMetadata(proto.constructor, n, key, value);
                    };
                    break;
                case 'methodParameter':
                    decSet.methodParameter = (p, n, i) => {
                        this.setMethodParameterMetadata(p.constructor, n, i, key, value);
                    };
                    break;
                case 'property':
                    decSet.property = (p, n) => {
                        this.setPropertyMetadata(p.constructor, n, key, value);
                    };
                    break;
                case 'staticAccessor':
                    decSet.staticAccessor = (c, n) => {
                        this.setStaticAccessorMetadata(c, n, key, value);
                    };
                    break;
                case 'staticMethod':
                    decSet.staticMethod = (c, n) => {
                        this.setStaticMethodMetadata(c, n, key, value);
                    };
                    break;
                case 'staticMethodParameter':
                    decSet.staticMethodParameter = (c, n, i) => {
                        this.setStaticMethodParameterMetadata(c, n, i, key, value);
                    };
                    break;
                case 'staticProperty':
                    decSet.staticProperty = (c, n) => {
                        this.setStaticPropertyMetadata(c, n, key, value);
                    };
                    break;
                default:
                    throw new RangeError(`Invalid decoration position "${k}".`);
            }
        }
        return decorator_1.default.createGeneralDecorator(decSet);
    }
    createMethodMetadataDecorator(key, value) {
        return decorator_1.default.createMethodDecorator((proto, name) => {
            this.setMethodMetadata(proto.constructor, name, key, value);
        });
    }
    createMethodParameterMetadataDecorator(key, value) {
        return decorator_1.default.createMethodParameterDecorator((proto, name, index) => {
            this.setMethodParameterMetadata(proto.constructor, name, index, key, value);
        });
    }
    createPropertyMetadataDecorator(key, value) {
        return decorator_1.default.createPropertyDecorator((proto, name) => {
            this.setPropertyMetadata(proto.constructor, name, key, value);
        });
    }
    createStaticAccessorMetadataDecorator(key, value) {
        return decorator_1.default.createStaticAccessorDecorator((ctor, name) => {
            this.setStaticAccessorMetadata(ctor, name, key, value);
        });
    }
    createStaticMethodMetadataDecorator(key, value) {
        return decorator_1.default.createStaticMethodDecorator((ctor, name) => {
            this.setStaticMethodMetadata(ctor, name, key, value);
        });
    }
    createStaticMethodParameterMetadataDecorator(key, value) {
        return decorator_1.default.createStaticMethodParameterDecorator((ctor, name, index) => {
            this.setStaticMethodParameterMetadata(ctor, name, index, key, value);
        });
    }
    createStaticPropertyMetadataDecorator(key, value) {
        return decorator_1.default.createStaticPropertyDecorator((ctor, name) => {
            this.setStaticPropertyMetadata(ctor, name, key, value);
        });
    }
    configureMetadata(key, opts) {
        const $data = privData.get(this).metadata;
        const originOpts = getMetadataDefinition(this, key);
        for (const k of ['validator', 'onDuplicated', 'wrapper']) {
            // @ts-ignore
            originOpts[k] = opts[k];
        }
        $data.set(key, originOpts);
    }
    getConstructorParameterTypes(ctor) {
        var _a;
        return (_a = Reflect.getMetadata('design:paramtypes', ctor)) !== null && _a !== void 0 ? _a : null;
    }
    getMethodParameterTypes(ctor, name) {
        var _a;
        return (_a = Reflect.getMetadata('design:paramtypes', ctor.prototype, name)) !== null && _a !== void 0 ? _a : null;
    }
    getStaticMethodParameterTypes(ctor, name) {
        var _a;
        return (_a = Reflect.getMetadata('design:paramtypes', ctor, name)) !== null && _a !== void 0 ? _a : null;
    }
    getAccessorType(ctor, name) {
        var _a;
        return (_a = Reflect.getMetadata('design:type', ctor.prototype, name)) !== null && _a !== void 0 ? _a : null;
    }
    getStaticAccessorType(ctor, name) {
        var _a;
        return (_a = Reflect.getMetadata('design:type', ctor, name)) !== null && _a !== void 0 ? _a : null;
    }
    getAccessorParameterType(ctor, name) {
        const ret = Reflect.getMetadata('design:paramtypes', ctor.prototype, name);
        if (Array.isArray(ret)) {
            return ret[0];
        }
        return null;
    }
    getStaticAccessorParameterType(ctor, name) {
        const ret = Reflect.getMetadata('design:paramtypes', ctor, name);
        if (Array.isArray(ret)) {
            return ret[0];
        }
        return null;
    }
    getPropertyType(ctor, name) {
        var _a;
        return (_a = Reflect.getMetadata('design:type', ctor.prototype, name)) !== null && _a !== void 0 ? _a : null;
    }
    getStaticPropertyType(ctor, name) {
        var _a;
        return (_a = Reflect.getMetadata('design:type', ctor, name)) !== null && _a !== void 0 ? _a : null;
    }
    getMethodReturnType(ctor, name) {
        let ret = Reflect.getMetadata('design:returntype', ctor.prototype, name);
        if (ret === undefined) {
            ret = Reflect.hasMetadata('design:returntype', ctor.prototype, name) ? undefined : null;
        }
        return ret;
    }
    getStaticMethodReturnType(ctor, name) {
        let ret = Reflect.getMetadata('design:returntype', ctor, name);
        if (ret === undefined) {
            ret = Reflect.hasMetadata('design:returntype', ctor, name) ? undefined : null;
        }
        return ret;
    }
}
function createReflectManager() {
    return new ReflectManager();
}
exports.createReflectManager = createReflectManager;
//# sourceMappingURL=ReflectManager.js.map