"use strict";
/**
 * Copyright 2023 Angus.Fenying <fenying@litert.org>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.HttpClientResponse = void 0;
const E = require("../Errors");
const $zlib = require("zlib");
const HTTP_STATUS_CODE_SUCCESS_MIN = 200;
const HTTP_STATUS_CODE_SUCCESS_MAX = 299;
const HTTP_STATUS_CODE_REDIRECT_MIN = 300;
const HTTP_STATUS_CODE_REDIRECT_MAX = 399;
const HTTP_STATUS_CODE_CLIENT_ERROR_MIN = 400;
const HTTP_STATUS_CODE_CLIENT_ERROR_MAX = 499;
const HTTP_STATUS_CODE_SERVER_ERROR_MIN = 400;
const HTTP_STATUS_CODE_SERVER_ERROR_MAX = 499;
const HTTP_STATUS_CODE_CONTINUE = 100;
const HTTP_STATUS_CODE_UPGRADE = 101;
const EMPTY_BUFFER = Buffer.allocUnsafe(0);
class HttpClientResponse {
    constructor(_protocol, _stream, _contentLength, _headers, _statusCode, _gzip, _deflate, _noEntity) {
        this._protocol = _protocol;
        this._stream = _stream;
        this._contentLength = _contentLength;
        this._headers = _headers;
        this._statusCode = _statusCode;
        this._gzip = _gzip;
        this._deflate = _deflate;
        this._noEntity = _noEntity;
    }
    abort() {
        const s = this._stream;
        if (s.close) {
            s.close();
        }
        else {
            s.destroy();
        }
    }
    get headers() {
        return this._headers;
    }
    get statusCode() {
        return this._statusCode;
    }
    get contentLength() {
        return this._contentLength;
    }
    get protocol() {
        return this._protocol;
    }
    getBuffer(maxLength = Infinity) {
        if (maxLength <= 0 || this.contentLength <= 0 || this._noEntity) {
            return Promise.resolve(EMPTY_BUFFER);
        }
        return new Promise((resolve, reject) => {
            const resp = this._stream;
            const data = [];
            let stream = resp;
            if (this._gzip && this._headers['content-encoding'] === 'gzip') {
                stream = resp.pipe($zlib.createGunzip());
            }
            else if (this._deflate && this._headers['content-encoding'] === 'deflate') {
                stream = resp.pipe($zlib.createInflate());
            }
            stream.on('data', (maxLength && maxLength !== Infinity) ? (function () {
                let length = 0;
                return function (chunk) {
                    length += chunk.byteLength;
                    if (length > maxLength) {
                        stream.removeAllListeners('error');
                        stream.removeAllListeners('data');
                        stream.removeAllListeners('end');
                        if (stream !== resp) {
                            resp.removeAllListeners('error');
                        }
                        resp.destroy();
                        reject(new E.E_TOO_LARGE_RESPONSE_ENTITY());
                        return;
                    }
                    data.push(chunk);
                };
            })() : function (chunk) {
                data.push(chunk);
            }).on('end', function () {
                resolve(Buffer.concat(data));
            }).once('error', reject);
            if (stream !== resp) {
                resp.once('error', reject);
            }
        });
    }
    getStream() {
        if (this._noEntity || this._statusCode === 204) {
            throw new E.E_NO_RESPONSE_ENTITY();
        }
        const resp = this._stream;
        if (this._gzip && this._headers['content-encoding'] === 'gzip') {
            return resp.pipe($zlib.createGunzip());
        }
        else if (this._deflate && this._headers['content-encoding'] === 'deflate') {
            return resp.pipe($zlib.createInflate());
        }
        return resp;
    }
    getRawStream() {
        if (this._noEntity || this._statusCode === 204) {
            throw new E.E_NO_RESPONSE_ENTITY();
        }
        return this._stream;
    }
    isSuccess() {
        return this._statusCode >= HTTP_STATUS_CODE_SUCCESS_MIN &&
            this._statusCode <= HTTP_STATUS_CODE_SUCCESS_MAX;
    }
    isRedirection() {
        return this._statusCode >= HTTP_STATUS_CODE_REDIRECT_MIN &&
            this._statusCode <= HTTP_STATUS_CODE_REDIRECT_MAX;
    }
    isClientError() {
        return this._statusCode >= HTTP_STATUS_CODE_CLIENT_ERROR_MIN &&
            this._statusCode <= HTTP_STATUS_CODE_CLIENT_ERROR_MAX;
    }
    isServerError() {
        return this._statusCode >= HTTP_STATUS_CODE_SERVER_ERROR_MIN &&
            this._statusCode <= HTTP_STATUS_CODE_SERVER_ERROR_MAX;
    }
    isContinue() {
        return this._statusCode === HTTP_STATUS_CODE_CONTINUE;
    }
    isUpgrade() {
        return this._statusCode === HTTP_STATUS_CODE_UPGRADE;
    }
}
exports.HttpClientResponse = HttpClientResponse;
//# sourceMappingURL=Response.js.map