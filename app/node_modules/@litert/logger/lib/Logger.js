"use strict";
/**
 *  Copyright 2022 Angus.Fenying <fenying@litert.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *    https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const Common_1 = require("./Common");
function emptyLogMethod() {
    return;
}
/**
 * Create a logging method, works like a JIT compiler.
 */
function createLogMethod(subject, level, traceDepth, driver, formatter) {
    const cs = [];
    cs.push('return function(log, now = new Date()) {');
    if (traceDepth) {
        cs.push('let tmpObj = {};');
        cs.push(`Error.captureStackTrace(tmpObj, this.${level});`);
        cs.push('let traces = tmpObj.stack.split(');
        cs.push('   /\\n\\s+at\\s+/');
        cs.push(`).slice(1, ${traceDepth + 1});`);
    }
    subject = subject.replace(/"/g, '\\"');
    level = level.replace(/"/g, '\\"');
    cs.push('driver.write(');
    cs.push('    formatter(');
    cs.push('        log,');
    cs.push(`        "${subject}",`);
    cs.push(`        "${level}",`);
    if (traceDepth) {
        cs.push('        now,');
        cs.push('        traces');
    }
    else {
        cs.push('        now');
    }
    cs.push('    ),');
    cs.push(`    "${subject}",`);
    cs.push(`    "${level}",`);
    cs.push('    now');
    cs.push(');');
    cs.push('return this;');
    cs.push('};');
    return (new Function('formatter', 'driver', cs.join('\n')))(formatter, driver);
}
class Logger {
    constructor(subject, driver, settings, wraper, levels = Common_1.DEFAULT_LEVELS) {
        this._options = {};
        this._levels = levels;
        this._driver = driver;
        this._subject = subject;
        this._formatter = wraper;
        for (const lv of levels) {
            this._options[lv] = {
                enabled: settings[lv].enabled,
                trace: settings[lv].trace
            };
            this._updateMethod(lv);
        }
    }
    flush() {
        return this._driver.flush();
    }
    getSubject() {
        return this._subject;
    }
    getLevels() {
        return [...this._levels];
    }
    enableTrace(depth = 1, levels) {
        if (!levels || levels.length === 0) {
            levels = this._levels.slice();
        }
        else if (typeof levels === 'string') {
            levels = [levels];
        }
        for (const level of levels) {
            this._options[level].trace = depth;
            this._updateMethod(level);
        }
        return this;
    }
    unmute(levels) {
        if (!levels || !levels.length) {
            levels = this._levels;
        }
        else if (typeof levels === 'string') {
            levels = [levels];
        }
        for (const level of levels) {
            this._options[level].enabled = true;
            this._updateMethod(level);
        }
        return this;
    }
    mute(levels) {
        if (!levels || !levels.length) {
            levels = this._levels;
        }
        else if (typeof levels === 'string') {
            levels = [levels];
        }
        for (const level of levels) {
            this._options[level].enabled = false;
            this._updateMethod(level);
        }
        return this;
    }
    _updateMethod(lv) {
        // @ts-expect-error
        this[lv] = this._options[lv].enabled ? createLogMethod(this._subject, lv, this._options[lv].trace, this._driver, this._formatter) : emptyLogMethod;
    }
}
exports.default = Logger;
//# sourceMappingURL=Logger.js.map