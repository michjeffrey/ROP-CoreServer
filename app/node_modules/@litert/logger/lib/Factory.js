"use strict";
/**
 *  Copyright 2022 Angus.Fenying <fenying@litert.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *    https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.getDefaultFactory = exports.createFactory = void 0;
const Logger_1 = require("./Logger");
const Formatters_1 = require("./Formatters");
const Console_1 = require("./Drivers/Console");
const Common_1 = require("./Common");
class LoggerFactory {
    constructor(levels = Common_1.DEFAULT_LEVELS) {
        this._loggers = {};
        this._formatters = {
            'text': {
                'default': Formatters_1.DEFAULT_TEXT_FORMATTER
            },
            'data': {
                'default': Formatters_1.DEFAULT_JSON_FORMATTER
            }
        };
        this._drivers = {
            [Common_1.DEFAULT_DRIVER]: (0, Console_1.createConsoleDriver)()
        };
        this._levels = levels;
        this._globalConfig = {};
        for (const lv of levels) {
            this._globalConfig[lv] = {
                enabled: false,
                trace: 0
            };
        }
    }
    /**
     * Get the names list of registered drivers.
     */
    getDriverNames() {
        return Object.keys(this._drivers);
    }
    /**
     * Get the names list of registered formatters.
     */
    getDataFormatterNames() {
        return Object.keys(this._formatters.data);
    }
    /**
     * Get the names list of registered formatters.
     */
    getTextFormatterNames() {
        return Object.keys(this._formatters.text);
    }
    /**
     * Get the subjects list of created loggers.
     */
    getSubjects() {
        return Object.keys(this._loggers);
    }
    /**
     * Get the levels list of this factory supports.
     */
    getLevels() {
        return [...this._levels];
    }
    mute(levels) {
        if (!levels || !levels.length) {
            levels = this._levels;
        }
        else if (typeof levels === 'string') {
            levels = [levels];
        }
        for (const level of levels) {
            this._globalConfig[level].enabled = false;
        }
        for (const subject in this._loggers) {
            this._loggers[subject].mute(levels);
        }
        return this;
    }
    unmute(levels) {
        if (!levels || !levels.length) {
            levels = this._levels;
        }
        else if (typeof levels === 'string') {
            levels = [levels];
        }
        for (const level of levels) {
            this._globalConfig[level].enabled = true;
        }
        for (const subject in this._loggers) {
            this._loggers[subject].unmute(levels);
        }
        return this;
    }
    enableTrace(depth = 1, levels) {
        if (!levels || levels.length === 0) {
            levels = this._levels.slice();
        }
        else if (typeof levels === 'string') {
            levels = [levels];
        }
        for (const lv of levels) {
            this._globalConfig[lv].trace = depth;
            for (const subject in this._loggers) {
                this._loggers[subject].enableTrace(depth, lv);
            }
        }
        return this;
    }
    registerDriver(name, driver) {
        if (this._drivers[name]) {
            return false;
        }
        this._drivers[name] = driver;
        return true;
    }
    getDriver(name) {
        return this._drivers[name] || null;
    }
    getDataFormatter(name) {
        return this._formatters.data[name] || null;
    }
    getTextFormatter(name) {
        return this._formatters.text[name] || null;
    }
    registerDataFormatter(name, formatter) {
        if (this._formatters.data[name]) {
            return false;
        }
        this._formatters.data[name] = formatter;
        return true;
    }
    registerTextFormatter(name, formatter) {
        if (this._formatters.text[name]) {
            return false;
        }
        this._formatters.text[name] = formatter;
        return true;
    }
    createTextLogger(subject = Common_1.DEFAULT_SUBJECT, formatter = 'default', driver = Common_1.DEFAULT_DRIVER) {
        const formatterFn = typeof formatter === 'string' ? this._formatters.text[formatter] : formatter;
        if (typeof formatterFn !== 'function') {
            throw new TypeError(`Unknown formatter ${formatter}`);
        }
        return this.createDataLogger(subject, formatterFn, driver);
    }
    createDataLogger(subject = Common_1.DEFAULT_SUBJECT, formatter = 'default', driver = Common_1.DEFAULT_DRIVER) {
        if (this._loggers[subject]) {
            return this._loggers[subject];
        }
        const formatterFn = typeof formatter === 'string' ? this._formatters.data[formatter] : formatter;
        if (typeof formatterFn !== 'function') {
            throw new TypeError(`Unknown formatter ${formatter}`);
        }
        return this._loggers[subject] = new Logger_1.default(subject, this.getDriver(driver), this._globalConfig, formatterFn, this._levels);
    }
}
/**
 * Create a new factory object.
 */
function createFactory(levels) {
    return new LoggerFactory(levels);
}
exports.createFactory = createFactory;
/**
 * The default factory object.
 */
const factory = createFactory(Common_1.DEFAULT_LEVELS);
/**
 * Get the default factory object.
 */
function getDefaultFactory() {
    return factory;
}
exports.getDefaultFactory = getDefaultFactory;
//# sourceMappingURL=Factory.js.map