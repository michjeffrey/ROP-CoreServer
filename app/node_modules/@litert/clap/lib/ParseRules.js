"use strict";
/**
 *  Copyright 2021 Angus.Fenying <fenying@litert.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *    https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ParseRulesVessel = exports.EFlagType = void 0;
const E = require("./Errors");
const _ = require("./Utils");
var EFlagType;
(function (EFlagType) {
    EFlagType[EFlagType["FLAG"] = 0] = "FLAG";
    EFlagType[EFlagType["OPTION"] = 1] = "OPTION";
})(EFlagType = exports.EFlagType || (exports.EFlagType = {}));
class ParseRulesVessel {
    constructor(
    /**
     * The config of command bound with current rules vessel.
     */
    info, parent) {
        var _a, _b, _c, _d;
        this.parent = parent;
        this._flagLikeEntries = {};
        this._flagLikeShortcut2Name = {};
        this._cmdShortcut2Name = {};
        this._flags = {};
        this._options = {};
        this._commands = {};
        this.info = {
            name: info.name,
            description: (_a = info.description) !== null && _a !== void 0 ? _a : '',
            shortcut: (_b = info.shortcut) !== null && _b !== void 0 ? _b : '',
            maxArguments: (_c = info.maxArguments) !== null && _c !== void 0 ? _c : -1,
            minArguments: (_d = info.minArguments) !== null && _d !== void 0 ? _d : 0
        };
    }
    get isCommandMode() {
        return Object.keys(this._commands).length > 0;
    }
    get countOptions() {
        var _a, _b;
        return Object.keys(this._options).length + ((_b = (_a = this.parent) === null || _a === void 0 ? void 0 : _a.countOptions) !== null && _b !== void 0 ? _b : 0);
    }
    get countFlags() {
        var _a, _b;
        return Object.keys(this._flags).length + ((_b = (_a = this.parent) === null || _a === void 0 ? void 0 : _a.countFlags) !== null && _b !== void 0 ? _b : 0);
    }
    get isRoot() {
        return !this.parent;
    }
    getCommandNames() {
        return Object.keys(this._commands);
    }
    getOptionNames() {
        const ret = [];
        if (this.parent) {
            ret.push(...this.parent.getOptionNames());
        }
        ret.push(...Object.keys(this._options));
        return ret;
    }
    getFlagNames() {
        const ret = [];
        if (this.parent) {
            ret.push(...this.parent.getFlagNames());
        }
        ret.push(...Object.keys(this._flags));
        return ret;
    }
    _toIndexFlagName(name) {
        if (name.length === 1) {
            return name;
        }
        return name.toLowerCase();
    }
    _toIndexCommandName(name) {
        return name.toLowerCase();
    }
    existCommand(name) {
        var _a;
        name = this._toIndexCommandName(name);
        return !!this._commands[(_a = this._cmdShortcut2Name[name]) !== null && _a !== void 0 ? _a : name];
    }
    existOption(name) {
        var _a;
        name = this._toIndexFlagName(name);
        return this._flagLikeEntries[name] === EFlagType.OPTION || !!((_a = this.parent) === null || _a === void 0 ? void 0 : _a.existOption(name));
    }
    existFlag(name) {
        var _a;
        name = this._toIndexFlagName(name);
        return this._flagLikeEntries[name] === EFlagType.FLAG || !!((_a = this.parent) === null || _a === void 0 ? void 0 : _a.existFlag(name));
    }
    getCommandRules(name) {
        var _a;
        name = this._toIndexCommandName(name);
        if (this.isUnusedCommandNameOrShortcut(name)) {
            throw new E.E_NO_SUCH_COMMAND({ name });
        }
        return this._commands[(_a = this._cmdShortcut2Name[name]) !== null && _a !== void 0 ? _a : name];
    }
    getOption(name) {
        var _a, _b, _c;
        name = this._toIndexFlagName(name);
        if (!this.existOption(name) && !this.parent) {
            throw new E.E_NO_SUCH_OPTION({ name });
        }
        return (_b = this._options[(_a = this._flagLikeShortcut2Name[name]) !== null && _a !== void 0 ? _a : name]) !== null && _b !== void 0 ? _b : (_c = this.parent) === null || _c === void 0 ? void 0 : _c.getOption(name);
    }
    getFlag(name) {
        var _a, _b, _c;
        name = this._toIndexFlagName(name);
        if (!this.existFlag(name) && !this.parent) {
            throw new E.E_NO_SUCH_FLAG({ name });
        }
        return (_b = this._flags[(_a = this._flagLikeShortcut2Name[name]) !== null && _a !== void 0 ? _a : name]) !== null && _b !== void 0 ? _b : (_c = this.parent) === null || _c === void 0 ? void 0 : _c.getFlag(name);
    }
    /**
     * Tell if a name or shortcut for command is usable or not.
     */
    isUnusedCommandNameOrShortcut(name) {
        var _a;
        name = this._toIndexCommandName(name);
        return !this._commands[(_a = this._cmdShortcut2Name[name]) !== null && _a !== void 0 ? _a : name];
    }
    /**
     * Tell if a name or shortcut for both flag and option is usable or not.
     */
    isUnusedFlagLikeNameOrShortcut(name) {
        name = this._toIndexFlagName(name);
        return this._flagLikeEntries[name] === undefined;
    }
    addFlag(opts) {
        const name = opts.name = this._toIndexFlagName(opts.name);
        const shortcut = opts.shortcut = opts.shortcut && this._toIndexFlagName(opts.shortcut);
        if (!_.isValidFlagName(name)) {
            throw new E.E_INVALID_FLAG_NAME({ name });
        }
        if (!this.isUnusedFlagLikeNameOrShortcut(name)) {
            throw new E.E_DUP_FLAG_NAME({ name });
        }
        if (shortcut) {
            if (!_.isValidFlagShortcut(shortcut)) {
                throw new E.E_INVALID_FLAG_SHORTCUT({ name, shortcut });
            }
            if (!this.isUnusedFlagLikeNameOrShortcut(shortcut)) {
                throw new E.E_DUP_FLAG_SHORTCUT({ name, shortcut });
            }
            this._flagLikeShortcut2Name[shortcut] = name;
            this._flagLikeEntries[shortcut] = EFlagType.FLAG;
        }
        this._flags[name] = opts;
        this._flagLikeEntries[name] = EFlagType.FLAG;
    }
    addOption(opts) {
        const name = opts.name = this._toIndexFlagName(opts.name);
        const shortcut = opts.shortcut = opts.shortcut && this._toIndexFlagName(opts.shortcut);
        if (!_.isValidFlagName(name)) {
            throw new E.E_INVALID_OPTION_NAME({ name });
        }
        if (!this.isUnusedFlagLikeNameOrShortcut(name)) {
            throw new E.E_DUP_OPTION_NAME({ name });
        }
        if (shortcut) {
            if (!_.isValidFlagShortcut(shortcut)) {
                throw new E.E_INVALID_OPTION_SHORTCUT({ name, shortcut });
            }
            if (!this.isUnusedFlagLikeNameOrShortcut(shortcut)) {
                throw new E.E_DUP_OPTION_SHORTCUT({ name, shortcut });
            }
            this._flagLikeShortcut2Name[shortcut] = name;
            this._flagLikeEntries[shortcut] = EFlagType.OPTION;
        }
        this._options[name] = opts;
        this._flagLikeEntries[name] = EFlagType.OPTION;
    }
    addCommand(opts) {
        const name = opts.name = this._toIndexCommandName(opts.name);
        const shortcut = opts.shortcut = opts.shortcut && this._toIndexCommandName(opts.shortcut);
        if (!_.isValidCommandName(name)) {
            throw new E.E_INVALID_COMMAND_NAME({ name });
        }
        if (!this.isUnusedCommandNameOrShortcut(name)) {
            throw new E.E_DUP_COMMAND_NAME({ name });
        }
        if (shortcut) {
            if (!_.isValidCommandShortcut(shortcut)) {
                throw new E.E_INVALID_COMMAND_SHORTCUT({ name, shortcut });
            }
            if (!this.isUnusedCommandNameOrShortcut(shortcut)) {
                throw new E.E_DUP_COMMAND_SHORTCUT({ name, shortcut });
            }
            this._cmdShortcut2Name[shortcut] = name;
        }
        this._commands[name] = new ParseRulesVessel(opts, this);
    }
}
exports.ParseRulesVessel = ParseRulesVessel;
//# sourceMappingURL=ParseRules.js.map