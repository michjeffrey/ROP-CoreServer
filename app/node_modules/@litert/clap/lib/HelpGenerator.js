"use strict";
/**
 *  Copyright 2021 Angus.Fenying <fenying@litert.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *    https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.HelpGenerator = void 0;
const E = require("./Errors");
class ConsoleTextGenerator {
    constructor() {
        this._lines = [];
        this._indentWidth = 0;
        this._indent = '';
    }
    indentIn() {
        this._indentWidth += 1;
        this._indent = '  '.repeat(this._indentWidth);
    }
    indentOut() {
        this._indentWidth -= 1;
        if (this._indentWidth < 0) {
            this._indentWidth = 0;
        }
        this._indent = '  '.repeat(this._indentWidth);
    }
    appendLine(...lines) {
        lines = lines.map((v) => v.trimEnd()).filter((v) => v.length > 0);
        if (lines.length) {
            this._lines.push(...lines.map((v) => `${this._indent}${v}`));
        }
    }
    appendEmptyLine() {
        this._lines.push('');
    }
    getLines() {
        return [...this._lines];
    }
}
class HelpGenerator {
    constructor(_title, _command, _opts, _rules, _lang) {
        this._title = _title;
        this._command = _command;
        this._opts = _opts;
        this._rules = _rules;
        this._lang = _lang;
    }
    isHelpRequest(result) {
        var _a, _b;
        if (this._opts.disableHelpCommand && this._opts.disableHelpFlag) {
            return false;
        }
        return (!this._opts.disableHelpCommand && ((_b = (_a = result.commands) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.toLowerCase()) === 'help')
            || (!this._opts.disableHelpFlag && result.flags.help > 0);
    }
    _orEmpty(cond, text) {
        return cond ? text : '';
    }
    generate(result) {
        var _a, _b;
        const gen = new ConsoleTextGenerator();
        gen.appendLine(this._title);
        if (this._rules.isCommandMode) {
            const [cmd, rules] = this._prepareCommands(result);
            const cmdPath = cmd.replace(/ /g, ':');
            const prefix = cmdPath ? `cmd:${cmdPath}:` : 'cmd:';
            gen.appendLine(this._buildUsageLine([
                `${this._lang['help:usage']}:`,
                this._command,
                this._orEmpty(this._rules.countFlags + this._rules.countOptions, `[...${this._lang['help:usage:options']}]`),
                cmd,
                this._orEmpty(rules.isCommandMode, this._lang['help:usage:command']),
                this._orEmpty(rules.countFlags + rules.countOptions, `[...${this._lang['help:usage:sub-options']}]`),
                this._orEmpty(rules.info.maxArguments, (_a = this._lang[`${prefix}arguments`]) !== null && _a !== void 0 ? _a : this._lang['help:usage:arguments']),
            ]));
            gen.appendEmptyLine();
            gen.appendLine((_b = this._lang[`${prefix}desc`]) !== null && _b !== void 0 ? _b : rules.info.description);
            if (rules.isCommandMode) {
                this._generateCommands(prefix, gen, rules);
            }
            if (rules.countFlags + rules.countOptions) {
                this._generateOptions(prefix, gen, rules);
            }
        }
        else {
            gen.appendLine(this._buildUsageLine([
                `${this._lang['help:usage']}:`,
                this._command,
                this._orEmpty(this._rules.countFlags + this._rules.countOptions, `[...${this._lang['help:usage:options']}]`),
                this._orEmpty(this._rules.info.maxArguments, this._lang['help:usage:arguments'])
            ]));
            gen.appendEmptyLine();
            gen.appendLine(this._rules.info.description);
            if (this._rules.countFlags + this._rules.countOptions) {
                this._generateOptions(``, gen, this._rules);
            }
        }
        return gen.getLines();
    }
    _generateCommands(prefix, gen, rules) {
        gen.appendEmptyLine();
        gen.appendLine(`${this._lang['help:commands']}:`);
        gen.appendEmptyLine();
        gen.indentIn();
        const lines = [];
        for (const name of rules.getCommandNames().sort()) {
            const i = rules.getCommandRules(name).info;
            lines.push([
                i.shortcut ? `${i.name}, ${i.shortcut}` : `${i.name}`,
                (i.description || this._lang[`${prefix}${i.name}:desc`] || '').trim()
            ]);
        }
        const leftLength = Math.max(...lines.map((v) => v[0].length));
        for (const ln of lines) {
            if (/\r|\n/.test(ln[1])) {
                const [ln1, ...lns] = ln[1].split(/\r\n|\r|\n/);
                gen.appendLine(`${ln[0]}${ln1.padStart(ln1.length + 2 + leftLength - ln[0].length, ' ')}`);
                gen.appendLine(...lns.map((l) => l.padStart(l.length + 2 + leftLength, ' ')));
            }
            else {
                gen.appendLine(`${ln[0]}${ln[1].padStart(ln[1].length + 2 + leftLength - ln[0].length, ' ')}`);
            }
        }
        gen.indentOut();
    }
    _generateOptions(prefix, gen, rules) {
        var _a, _b, _c, _d, _e;
        gen.appendEmptyLine();
        gen.appendLine(`${this._lang['help:options']}:`);
        gen.appendEmptyLine();
        gen.indentIn();
        const lines = [];
        for (const name of Array.from(new Set([
            ...rules.getOptionNames(),
            ...rules.getFlagNames()
        ])).sort()) {
            if (rules.existFlag(name)) {
                const i = rules.getFlag(name);
                lines.push([
                    i.shortcut ? `-${i.shortcut}, --${i.name}` : `    --${i.name}`,
                    ((_b = (_a = i.description) !== null && _a !== void 0 ? _a : this._lang[`${prefix}flags:${i.name}:desc`]) !== null && _b !== void 0 ? _b : '').trim()
                ]);
            }
            else {
                const i = rules.getOption(name);
                const aName = (_c = this._lang[`${prefix}flags:${i.name}:argument`]) !== null && _c !== void 0 ? _c : '<arg>';
                lines.push([
                    i.shortcut ? `-${i.shortcut}, --${i.name} ${aName}` : `    --${i.name} ${aName}`,
                    ((_e = (_d = i.description) !== null && _d !== void 0 ? _d : this._lang[`${prefix}flags:${i.name}:desc`]) !== null && _e !== void 0 ? _e : '').trim()
                ]);
            }
        }
        const leftLength = Math.max(...lines.map((v) => v[0].length));
        for (const ln of lines) {
            if (/\r|\n/.test(ln[1])) {
                const [ln1, ...lns] = ln[1].split(/\r\n|\r|\n/);
                gen.appendLine(`${ln[0]}${ln1.padStart(ln1.length + 2 + leftLength - ln[0].length, ' ')}`);
                gen.appendLine(...lns.map((l) => l.padStart(l.length + 2 + leftLength, ' ')));
            }
            else {
                gen.appendLine(`${ln[0]}${ln[1].padStart(ln[1].length + 2 + leftLength - ln[0].length, ' ')}`);
            }
        }
        gen.indentOut();
    }
    _buildUsageLine(segs) {
        return segs.filter((v) => v.length > 0).join(' ');
    }
    _prepareCommands(result) {
        const validCmds = [];
        let cmds = [];
        let rules = this._rules;
        if (!result) {
            return ['', rules];
        }
        if (!this._opts.disableHelpCommand) {
            if (result.commands[0] === 'help') {
                cmds = result.arguments;
            }
            else {
                cmds = result.commands;
            }
            cmds = cmds.map((v) => v.toLowerCase()).filter((v) => v !== 'help');
        }
        for (const k of cmds) {
            if (rules.existCommand(k)) {
                rules = rules.getCommandRules(k);
                validCmds.push(rules.info.name);
            }
            else {
                throw new E.E_NO_SUCH_COMMAND({ name: k });
            }
        }
        return [validCmds.join(' '), rules];
    }
    generateErrorOutput(e) {
        const gen = new ConsoleTextGenerator();
        if (!E.errorRegistry.identify(e)) {
            gen.appendLine(`ERROR unknown: ${this._lang['errors.unknown']}`);
        }
        else {
            gen.appendLine(`ERROR ${e.name}: ${e.message}`);
        }
        if (!this._opts.disableHelpCommand && !this._opts.disableHelpFlag) {
            gen.appendEmptyLine();
            gen.appendLine(`${this._lang['errors.help.tips']}:`);
            gen.indentIn();
            if (!this._opts.disableHelpCommand && this._rules.isCommandMode) {
                gen.appendLine(`${this._command} help [...COMMAND]`);
            }
            else if (!this._opts.disableHelpFlag) {
                const cmd = this._rules.isCommandMode ? `${this._command} [...COMMAND]` : this._command;
                gen.appendLine(`${cmd} --help`);
                if (!this._opts.disableHelpFlagShortcut) {
                    gen.appendLine(`${cmd} -h`);
                }
            }
            gen.indentOut();
        }
        return gen.getLines();
    }
}
exports.HelpGenerator = HelpGenerator;
//# sourceMappingURL=HelpGenerator.js.map