/**
 *  Copyright 2021 Angus.Fenying <fenying@litert.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *    https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
/// <reference types="node" />
import * as C from './Common';
import { Readable } from 'stream';
export declare type IAlgorithms = 'sha1' | 'sha224' | 'sha256' | 'sha384' | 'sha512' | 'sha3-224' | 'sha3-256' | 'sha3-384' | 'sha3-512';
export declare function getSupportedAlgorithms(): IAlgorithms[];
export interface IECDSAOptions {
    keyPassphrase?: string | Buffer;
    /**
     * The output format of signature.
     *
     * @default 'ieee-p1363
     */
    format?: 'ieee-p1363' | 'der';
}
/**
 * This method helps transform signature from DER format to IEEE-P1363 format.
 *
 * @param {Buffer} der  The signature in DER format.
 *
 * @returns {Buffer}  Return the signature in IEEE-P1363 format.
 */
export declare function derToP1363(der: Buffer): Buffer;
/**
 * This method helps transform signature from DER format to IEEE-P1363 format.
 *
 * @param {Buffer} p1363   The signature in IEEE-P1363 format.
 *
 * @returns {Buffer}  Return the signature in DER format.
 */
export declare function p1363ToDER(p1363: Buffer): Buffer;
declare function signWithCustomP1363(algo: IAlgorithms, privateKey: string | Buffer, message: Buffer | string, opts?: IECDSAOptions): Buffer;
export declare let sign: typeof signWithCustomP1363;
declare function verifyWithCustomP1363(algo: IAlgorithms, publicKey: string | Buffer, message: Buffer | string, signature: Buffer, opts?: IECDSAOptions): boolean;
export declare let verify: typeof verifyWithCustomP1363;
export declare let signStream: typeof signStreamWithCustomP1363;
export declare function signStreamWithNativeP1363(algo: IAlgorithms, privateKey: string | Buffer, message: Readable, opts?: IECDSAOptions): Promise<Buffer>;
export declare function signStreamWithCustomP1363(algo: IAlgorithms, privateKey: string | Buffer, message: Readable, opts?: IECDSAOptions): Promise<Buffer>;
export declare let verifyStream: typeof verifyStreamWithCustomP1363;
export declare function verifyStreamWithNativeP1363(algo: IAlgorithms, publicKey: string | Buffer, message: Readable, signature: Buffer, opts?: IECDSAOptions): Promise<boolean>;
export declare function verifyStreamWithCustomP1363(algo: IAlgorithms, publicKey: string | Buffer, message: Readable, signature: Buffer, opts?: IECDSAOptions): Promise<boolean>;
export declare function createSigner(algo: IAlgorithms, publicKey: Buffer | string, privateKey: Buffer | string, opts?: IECDSAOptions): C.ISigner;
/**
 * Tell if current version of NodeJS supports native IEEE-P1363 formatter.
 */
export declare function hasNativeP1363Support(): boolean;
/**
 * Switch between NodeJS native IEEE-P1363 formater and custom one.
 *
 * > Use custom one by default.
 *
 * @param enabled Set to true to use native formatter.
 *
 * @returns Return true if native formatter is supported and switched successfully.
 */
export declare function enableNativeP1363(enabled?: boolean): boolean;
/**
 * Tell if it's using NodeJS native IEEE-P1363 formatter or not.
 */
export declare function isNativeP1363Enabled(): boolean;
export {};
//# sourceMappingURL=ECDSA.d.ts.map