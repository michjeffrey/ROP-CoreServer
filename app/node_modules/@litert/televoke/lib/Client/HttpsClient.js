"use strict";
/**
 * Copyright 2021 Angus.Fenying <fenying@litert.org>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.createHttpsClient = void 0;
const $Https = require("https");
const GE = require("../Errors");
const G = require("../Common");
const E = require("./Errors");
const observable_1 = require("@litert/observable");
class HttpsClient extends observable_1.Events.EventEmitter {
    constructor(_host, _port, _ridGenerator, _path = '', _timeout = 30000, _apiNameWrapper, tlsAgentOptions) {
        super();
        this._host = _host;
        this._port = _port;
        this._ridGenerator = _ridGenerator;
        this._path = _path;
        this._timeout = _timeout;
        this._apiNameWrapper = _apiNameWrapper;
        this._agent = new $Https.Agent(Object.assign({ maxSockets: 0, keepAlive: true, keepAliveMsecs: 30000 }, tlsAgentOptions));
    }
    invoke(api, ...args) {
        return this._call(api, false, args);
    }
    call(api, ...args) {
        return this._call(api, true, args);
    }
    _call(api, returnRaw, args) {
        const rid = this._ridGenerator();
        const CST = Date.now();
        const content = JSON.stringify({
            ttl: this._timeout,
            rid,
            cst: CST,
            args,
            api: this._apiNameWrapper ? this._apiNameWrapper(api) : api
        });
        return new Promise((resolve, reject) => {
            const length = Buffer.byteLength(content);
            if (length > G.MAX_PACKET_SIZE) {
                return reject(new GE.E_PACKET_TOO_LARGE());
            }
            const req = $Https.request({
                port: this._port,
                host: this._host,
                path: this._path,
                agent: this._agent,
                method: 'POST',
                headers: {
                    'content-length': Buffer.byteLength(content)
                },
                timeout: this._timeout
            }, (resp) => {
                if (!resp.headers['content-length']) {
                    return reject(new E.E_INVALID_RESPONSE());
                }
                const length = parseInt(resp.headers['content-length']);
                if (!Number.isSafeInteger(length) || length > G.MAX_PACKET_SIZE) { // Maximum request packet is 64MB
                    return reject(new GE.E_PACKET_TOO_LARGE());
                }
                const buf = Buffer.allocUnsafe(length);
                let offset = 0;
                resp.on('data', (chunk) => {
                    const index = offset;
                    offset += chunk.byteLength;
                    if (offset > length) {
                        resp.removeAllListeners('end');
                        resp.removeAllListeners('data');
                        resp.destroy();
                        return reject(new GE.E_INVALID_PACKET());
                    }
                    chunk.copy(buf, index);
                }).on('end', () => {
                    let rawData;
                    try {
                        rawData = JSON.parse(buf);
                    }
                    catch (_a) {
                        return reject(new GE.E_INVALID_PACKET());
                    }
                    const data = rawData;
                    data.cst = CST;
                    data.crt = Date.now();
                    switch (data.code) {
                        case G.EResponseCode.OK:
                            resolve(returnRaw ? data : data.body);
                            break;
                        case G.EResponseCode.SYSTEM_ERROR:
                            reject(new E.E_SERVER_INTERNAL_ERROR(Object.assign({ api }, data)));
                            break;
                        case G.EResponseCode.FAILURE:
                            reject(new E.E_SERVER_LOGIC_FAILURE(Object.assign({ api }, data)));
                            break;
                        case G.EResponseCode.API_NOT_FOUND:
                            reject(new E.E_API_NOT_FOUND(Object.assign({ api }, data)));
                            break;
                        default:
                            reject(new E.E_SERVER_UNKNOWN_ERROR(Object.assign({ api }, data)));
                            break;
                    }
                });
            });
            req.once('timeout', () => reject(new E.E_REQUEST_TIMEOUT({
                metadata: { api, requestId: rid, time: Date.now(), details: null }
            })));
            req.once('error', reject);
            req.end(content);
        });
    }
    connect() {
        return Promise.resolve();
    }
    close() {
        this._agent.destroy();
        return Promise.resolve();
    }
}
function createHttpsClient(opts) {
    var _a;
    return new HttpsClient(opts.host, (_a = opts.port) !== null && _a !== void 0 ? _a : 443, opts.ridGenerator, opts.path, opts.timeout, opts.apiNameWrapper, opts.tlsAgentOptions);
}
exports.createHttpsClient = createHttpsClient;
//# sourceMappingURL=HttpsClient.js.map