"use strict";
/**
 * Copyright 2021 Angus.Fenying <fenying@litert.org>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.createTLSClient = void 0;
const $TLS = require("tls");
const G = require("../Common");
const observable_1 = require("@litert/observable");
const E = require("./Errors");
const Decoder_1 = require("../Encoder/Decoder");
const Encoder_1 = require("../Encoder/Encoder");
const observable_2 = require("@litert/observable");
var EStatus;
(function (EStatus) {
    EStatus[EStatus["IDLE"] = 0] = "IDLE";
    EStatus[EStatus["CONNECTING"] = 1] = "CONNECTING";
    EStatus[EStatus["CLOSING"] = 2] = "CLOSING";
    EStatus[EStatus["WORKING"] = 3] = "WORKING";
})(EStatus || (EStatus = {}));
class TLSClient extends observable_2.Events.EventEmitter {
    constructor(_host, _port, _ridGenerator, _timeout = 30000, _apiNameWrapper, _tlsOptions) {
        super();
        this._host = _host;
        this._port = _port;
        this._ridGenerator = _ridGenerator;
        this._timeout = _timeout;
        this._apiNameWrapper = _apiNameWrapper;
        this._tlsOptions = _tlsOptions;
        this._status = EStatus.IDLE;
        this._clientId = TLSClient._$clientCounter++;
        this._sent = {};
        this._sentQty = 0;
        this._sending = {};
        this._sendingQty = 0;
        this._encoder = Encoder_1.createEncoder();
        this._connPrId = `litert:televoke:tcp:client:${this._clientId}:connect`;
        this._closePrId = `litert:televoke:tcp:client:${this._clientId}:close`;
    }
    invoke(api, ...args) {
        return this._call(api, false, args);
    }
    call(api, ...args) {
        return this._call(api, true, args);
    }
    _call(api, returnRaw, args) {
        const rid = this._ridGenerator();
        let pr;
        switch (this._status) {
            case EStatus.IDLE:
                return Promise.reject(new E.E_CONN_NOT_READY());
            case EStatus.WORKING: {
                const NOW = Date.now();
                this._encoder.encode(this._socket, {
                    ttl: this._timeout,
                    rid,
                    cst: NOW,
                    args,
                    api: this._apiNameWrapper ? this._apiNameWrapper(api) : api
                });
                this._sentQty++;
                this._sent[rid] = {
                    api,
                    cst: NOW,
                    returnRaw,
                    pr: pr = TLSClient._$promises.createPromise(),
                    timer: this._timeout > 0 ? setTimeout(() => {
                        const req = this._sent[rid];
                        if (req) {
                            delete this._sent[rid];
                            this._sentQty--;
                            req.pr.reject(new E.E_REQUEST_TIMEOUT({
                                metadata: { api: req.api, requestId: rid, time: req.cst, details: null }
                            }));
                        }
                        if (this._status === EStatus.CLOSING && !this._sentQty) {
                            this._socket.destroy();
                            this._status = EStatus.IDLE;
                        }
                    }, this._timeout) : undefined
                };
                break;
            }
            case EStatus.CONNECTING: {
                const NOW = Date.now();
                this._sendingQty++;
                this._sending[rid] = {
                    api,
                    pr: pr = TLSClient._$promises.createPromise(),
                    cst: NOW,
                    returnRaw,
                    packet: {
                        ttl: this._timeout,
                        rid,
                        cst: NOW,
                        args,
                        api: this._apiNameWrapper ? this._apiNameWrapper(api) : api
                    },
                    timer: this._timeout > 0 ? setTimeout(() => {
                        let req = this._sent[rid];
                        if (req) {
                            delete this._sent[rid];
                            this._sentQty--;
                            req.pr.reject(new E.E_REQUEST_TIMEOUT({
                                metadata: { api: req.api, requestId: rid, time: req.cst, details: null }
                            }));
                            if (this._status === EStatus.CLOSING && !this._sentQty) {
                                this._socket.destroy();
                                this._status = EStatus.IDLE;
                            }
                            return;
                        }
                        req = this._sending[rid];
                        if (req) {
                            delete this._sending[rid];
                            this._sendingQty--;
                            req.pr.reject(new E.E_REQUEST_TIMEOUT({
                                metadata: { api: req.api, requestId: rid, time: req.cst, details: null }
                            }));
                            if (this._status === EStatus.CLOSING && !this._sentQty) {
                                this._socket.destroy();
                                this._status = EStatus.IDLE;
                            }
                        }
                    }, this._timeout) : undefined
                };
                break;
            }
            case EStatus.CLOSING:
                throw new E.E_CONN_CLOSING();
        }
        return pr.promise;
    }
    connect() {
        switch (this._status) {
            case EStatus.WORKING:
                return Promise.resolve();
            case EStatus.CONNECTING:
                return TLSClient._$promises.findPromise(this._connPrId).promise;
            case EStatus.CLOSING:
                this._status = EStatus.WORKING;
                break;
            case EStatus.IDLE:
                break;
        }
        this._socket = $TLS.connect(Object.assign({ host: this._host, port: this._port }, this._tlsOptions));
        const pr = TLSClient._$promises.createPromise({ id: this._connPrId });
        this._socket.once('connect', () => {
            this._status = EStatus.WORKING;
            this._socket.removeAllListeners('error');
            const decoder = Decoder_1.createDecoder();
            decoder.onLogicError = (e) => this.emit('error', e);
            decoder.onProtocolError = (e) => this.emit('error', e);
            decoder.onData = (rawData) => {
                const data = rawData;
                const req = this._sent[data.rid];
                if (!req) {
                    return;
                }
                data.cst = req.cst;
                data.crt = Date.now();
                this._sentQty--;
                delete this._sent[data.rid];
                if (req.timer) {
                    clearTimeout(req.timer);
                }
                if (this._status === EStatus.CLOSING && !this._sentQty) {
                    this._socket.end();
                    this._status = EStatus.IDLE;
                }
                switch (data.code) {
                    case G.EResponseCode.OK:
                        req.pr.resolve(req.returnRaw ? data : data.body);
                        break;
                    case G.EResponseCode.SYSTEM_ERROR:
                        req.pr.reject(new E.E_SERVER_INTERNAL_ERROR(Object.assign({ api: req.api }, data)));
                        break;
                    case G.EResponseCode.FAILURE:
                        req.pr.reject(new E.E_SERVER_LOGIC_FAILURE(Object.assign({ api: req.api }, data)));
                        break;
                    case G.EResponseCode.API_NOT_FOUND:
                        req.pr.reject(new E.E_API_NOT_FOUND(Object.assign({ api: req.api }, data)));
                        break;
                    default:
                        req.pr.reject(new E.E_SERVER_UNKNOWN_ERROR(Object.assign({ api: req.api }, data)));
                        break;
                }
            };
            this._socket.on('data', decoder.decode.bind(decoder)).on('end', () => {
                if (this._sentQty) {
                    const ls = this._sent;
                    this._sent = {};
                    for (const rid in ls) {
                        this._sent[rid].pr.reject(new E.E_CONN_LOST());
                    }
                    this._sentQty = 0;
                }
            });
            if (this._sendingQty) {
                for (const rid in this._sending) {
                    const req = this._sending[rid];
                    this._encoder.encode(this._socket, req.packet);
                    this._sent[rid] = req;
                    this._sentQty++;
                    delete req.packet;
                }
                this._sending = {};
                this._sendingQty = 0;
            }
            pr.resolve();
        }).once('error', (e) => {
            this._socket = undefined;
            pr.reject(e);
        });
        return pr.promise;
    }
    close() {
        switch (this._status) {
            case EStatus.IDLE:
                return Promise.resolve();
            case EStatus.CLOSING:
                return TLSClient._$promises.findPromise(this._closePrId).promise;
            case EStatus.WORKING:
                break;
            case EStatus.CONNECTING:
                TLSClient._$promises.findPromise(this._connPrId).reject(new E.E_OPERATION_ABORTED());
        }
        if (this._sentQty) {
            this._status = EStatus.CLOSING;
            return TLSClient._$promises.createPromise({ id: this._closePrId }).promise;
        }
        if (this._sendingQty) {
            for (const rid in this._sending) {
                const req = this._sending[rid];
                req.pr.reject(new E.E_CONN_LOST({
                    metadata: { api: req.api, requestId: rid, time: Date.now(), details: null }
                }));
            }
            this._sending = {};
        }
        this._socket.destroy();
        this._socket = undefined;
        this._status = EStatus.IDLE;
        return Promise.resolve();
    }
}
TLSClient._$promises = observable_1.Promises.getGlobalFactory();
TLSClient._$clientCounter = 0;
function createTLSClient(opts) {
    var _a;
    return new TLSClient(opts.host, (_a = opts.port) !== null && _a !== void 0 ? _a : 443, opts.ridGenerator, opts.timeout, opts.apiNameWrapper, opts.tlsOptions);
}
exports.createTLSClient = createTLSClient;
//# sourceMappingURL=TLSClient.js.map