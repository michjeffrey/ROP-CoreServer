"use strict";
/**
 * Copyright 2021 Angus.Fenying <fenying@litert.org>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.createTCPGateway = void 0;
const E = require("../Errors");
const $Net = require("net");
const Encoder_1 = require("../../Encoder/Encoder");
const Decoder_1 = require("../../Encoder/Decoder");
var EStatus;
(function (EStatus) {
    EStatus[EStatus["IDLE"] = 0] = "IDLE";
    EStatus[EStatus["STARTING"] = 1] = "STARTING";
    EStatus[EStatus["WORKING"] = 2] = "WORKING";
    EStatus[EStatus["CLOSING"] = 3] = "CLOSING";
})(EStatus || (EStatus = {}));
var EClientStatus;
(function (EClientStatus) {
    EClientStatus[EClientStatus["WORKING"] = 0] = "WORKING";
    EClientStatus[EClientStatus["CLOSING"] = 1] = "CLOSING";
})(EClientStatus || (EClientStatus = {}));
class TCPGateway {
    constructor(_host, _port, _backlog) {
        this._host = _host;
        this._port = _port;
        this._backlog = _backlog;
        this._socket = $Net.createServer(this._onConnect.bind(this));
        this._status = EStatus.IDLE;
        this._clients = {};
        this._clientIdCounter = 0;
    }
    _onConnect(socket) {
        const clientId = this._clientIdCounter++;
        const encoder = Encoder_1.createEncoder();
        const decoder = Decoder_1.createDecoder();
        const client = {
            decoder,
            socket,
            status: EClientStatus.WORKING,
            loads: 0
        };
        decoder.onLogicError = decoder.onProtocolError = (e) => {
            delete this._clients[clientId];
            socket.destroy();
            this.onError(e);
        };
        decoder.onData = (data) => {
            client.loads++;
            data.ip = socket.address().address;
            this.onRequest(data, (content) => {
                if (socket.writable) {
                    encoder.encode(socket, content);
                }
                if (!--client.loads && client.status === EClientStatus.CLOSING) {
                    socket.end();
                }
            });
        };
        this._clients[clientId] = client;
        socket.on('data', decoder.decode.bind(decoder)).on('end', () => {
            client.status = EClientStatus.CLOSING;
            delete this._clients[clientId];
        }).on('error', this.onError).on('close', () => delete this._clients[clientId]);
    }
    async start() {
        if (!this.onError || !this.onRequest) {
            throw new E.E_NO_SERVER_ATTACHED();
        }
        switch (this._status) {
            case EStatus.IDLE:
                this._status = EStatus.STARTING;
                return new Promise((resolve, reject) => {
                    this._socket.listen(this._port, this._host, this._backlog)
                        .once('listening', () => {
                        this._socket.removeAllListeners('error');
                        this._status = EStatus.WORKING;
                        resolve();
                    })
                        .once('error', (e) => {
                        this._socket.removeAllListeners('listening');
                        this._status = EStatus.IDLE;
                        reject(e);
                    });
                });
            case EStatus.STARTING:
                throw new E.E_GATEWAY_STARTING();
            case EStatus.CLOSING:
                throw new E.E_GATEWAY_CLOSING();
            case EStatus.WORKING:
                return;
        }
    }
    async close() {
        switch (this._status) {
            case EStatus.IDLE:
                return;
            case EStatus.STARTING:
                throw new E.E_GATEWAY_STARTING();
            case EStatus.CLOSING:
                throw new E.E_GATEWAY_CLOSING();
            case EStatus.WORKING:
                return new Promise((resolve) => {
                    this._socket.close(() => resolve());
                    for (const clientId in this._clients) {
                        this._closeClient(clientId);
                    }
                });
        }
    }
    _closeClient(clientId) {
        if (this._clients[clientId].loads) {
            this._clients[clientId].decoder.onData = () => void 0;
            this._clients[clientId].status = EClientStatus.CLOSING;
        }
        else {
            this._clients[clientId].socket.end();
        }
        delete this._clients[clientId];
    }
}
function createTCPGateway(host, port, backlog) {
    return new TCPGateway(host, port, backlog);
}
exports.createTCPGateway = createTCPGateway;
//# sourceMappingURL=TCP.js.map