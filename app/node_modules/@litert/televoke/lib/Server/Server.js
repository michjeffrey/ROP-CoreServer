"use strict";
/**
 * Copyright 2021 Angus.Fenying <fenying@litert.org>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.createServer = void 0;
const G = require("../Common");
const E = require("./Errors");
const observable_1 = require("@litert/observable");
var EStatus;
(function (EStatus) {
    EStatus[EStatus["IDLE"] = 0] = "IDLE";
    EStatus[EStatus["STARTING"] = 1] = "STARTING";
    EStatus[EStatus["WORKING"] = 2] = "WORKING";
    EStatus[EStatus["CLOSING"] = 3] = "CLOSING";
})(EStatus || (EStatus = {}));
class Server extends observable_1.Events.EventEmitter {
    constructor() {
        super(...arguments);
        this._gateways = {};
        this._status = EStatus.IDLE;
    }
    addGateway(name, gateway) {
        if (this._status !== EStatus.IDLE) {
            throw new E.E_SERVER_BUSY();
        }
        this._gateways[name] = gateway;
        if (gateway.onError || gateway.onRequest) {
            throw new E.E_GATEWAY_BUSY();
        }
        gateway.onError = (e) => this.emit('error', e);
        gateway.onRequest = (rawReq, reply) => {
            const req = rawReq;
            req.srt = Date.now();
            const handler = this._router.route(rawReq.api);
            if (!handler) {
                return reply({
                    rid: req.rid,
                    srt: req.srt,
                    sst: Date.now(),
                    code: G.EResponseCode.API_NOT_FOUND,
                    body: null
                });
            }
            if (!this._router.validate(req, handler)) {
                return reply({
                    rid: req.rid,
                    srt: req.srt,
                    sst: Date.now(),
                    code: G.EResponseCode.MALFORMED_ARGUMENTS,
                    body: null
                });
            }
            let resultPr;
            try {
                resultPr = this._router.execute(req, handler);
            }
            catch (e) {
                reply({
                    rid: req.rid,
                    srt: req.srt,
                    sst: Date.now(),
                    code: G.EResponseCode.FAILURE,
                    body: e !== null && e !== void 0 ? e : null
                });
                return;
            }
            if (resultPr instanceof Promise) {
                resultPr.then((body) => reply({
                    rid: req.rid,
                    srt: req.srt,
                    sst: Date.now(),
                    code: G.EResponseCode.OK,
                    body: body !== null && body !== void 0 ? body : null
                }), (body) => reply({
                    rid: req.rid,
                    srt: req.srt,
                    sst: Date.now(),
                    code: G.EResponseCode.FAILURE,
                    body: body !== null && body !== void 0 ? body : null
                }));
            }
            else {
                reply({
                    rid: req.rid,
                    srt: req.srt,
                    sst: Date.now(),
                    code: G.EResponseCode.OK,
                    body: resultPr !== null && resultPr !== void 0 ? resultPr : null
                });
            }
        };
        return this;
    }
    removeGateway(name) {
        if (this._status !== EStatus.IDLE) {
            throw new E.E_SERVER_BUSY();
        }
        const gateway = this._gateways[name];
        if (gateway) {
            delete this._gateways[name];
            delete gateway.onRequest;
            delete gateway.onError;
        }
        return this;
    }
    setRouter(router) {
        if (this._status !== EStatus.IDLE) {
            throw new E.E_SERVER_BUSY();
        }
        this._router = router;
        return this;
    }
    async start() {
        if (!this.listenerCount('error')
            || !this.listenerCount('handler_error')
            || !this._router
            || !Object.values(this._gateways).length) {
            throw new E.E_SERVER_NOT_READY();
        }
        switch (this._status) {
            case EStatus.IDLE: {
                this._status = EStatus.STARTING;
                try {
                    const gateways = Object.keys(this._gateways);
                    await Promise.all(gateways.map((k) => this._gateways[k].start()));
                    this._status = EStatus.WORKING;
                }
                catch (e) {
                    await this._doClose();
                    this._status = EStatus.IDLE;
                    throw e;
                }
                break;
            }
            case EStatus.STARTING:
                throw new E.E_SERVER_STARTING();
            case EStatus.CLOSING:
                throw new E.E_SERVER_CLOSING();
            case EStatus.WORKING:
                return;
        }
    }
    async _doClose() {
        await Promise.all(Object.values(this._gateways).map((k) => k.close()));
        this._status = EStatus.IDLE;
    }
    async close() {
        switch (this._status) {
            case EStatus.WORKING: {
                this._status = EStatus.CLOSING;
                try {
                    await this._doClose();
                }
                catch (e) {
                    this._status = EStatus.WORKING;
                    throw e;
                }
                break;
            }
            case EStatus.STARTING:
                throw new E.E_SERVER_STARTING();
            case EStatus.CLOSING:
                throw new E.E_SERVER_CLOSING();
            case EStatus.IDLE:
                return;
        }
    }
}
function createServer() {
    return new Server();
}
exports.createServer = createServer;
//# sourceMappingURL=Server.js.map