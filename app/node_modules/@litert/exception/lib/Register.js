"use strict";
/**
 * Copyright 2022 Angus.Fenying <fenying@litert.org>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.equals = exports.identify = exports.createExceptionRegistry = exports.E_DUP_EXCEPTION_CODE = exports.E_DUP_EXCEPTION_NAME = exports.E_MALFORMED_NAME = exports.E_MALFORMED_MODULE = exports.E_MALFORMED_TYPE = exports.E_DUP_TYPE = exports.E_TYPE_NOT_FOUND = void 0;
const BUILT_IN_TYPE_NAME = 'built_in';
const BUILT_IN_ERR_TYPE_NOT_FOUND = 'type_not_found';
const BUILT_IN_ERR_DUP_TYPE = 'dup_type';
const BUILT_IN_ERR_MALFORMED_TYPE = 'malformed_type';
const BUILT_IN_ERR_MALFORMED_NAME = 'malformed_name';
const BUILT_IN_ERR_MALFORMED_MODULE = 'malformed_module';
const BUILT_IN_ERR_DUP_EXCEPTION_NAME = 'dup_exception_name';
const BUILT_IN_ERR_DUP_EXCEPTION_CODE = 'dup_exception_code';
const VALIDATE_TYPE = /^(?!_)[_a-z0-9]+(?<!_)$/;
const VALIDATE_MODULE = /^(?!-)[-a-z0-9]+(?<!-)(\.(?!-)[-a-z0-9]+(?<!-))*$/;
const VALIDATE_NAME = /^(?!_)[_a-z0-9]+(?<!_)$/;
const URL_PROTOCOL = 'exception:';
class BaseException {
    constructor(metadata, origin, theCtor) {
        this.metadata = Object.assign(Object.assign({}, this.constructor.metadata), metadata);
        this.origin = origin;
        switch (typeof theCtor) {
            default:
            case 'function':
                Error.captureStackTrace(this, theCtor !== null && theCtor !== void 0 ? theCtor : this.constructor);
                break;
            case 'string':
                this.stack = theCtor;
                break;
        }
    }
    toString(onlyData = false) {
        var _a;
        if (onlyData) {
            return `${URL_PROTOCOL}//${this.module}/${this.type}/${this.name}?code=${this.code}&msg=${encodeURIComponent(this.message)}&meta=${encodeURIComponent(JSON.stringify(this.metadata))}`;
        }
        return `${URL_PROTOCOL}//${this.module}/${this.type}/${this.name}?code=${this.code}&msg=${encodeURIComponent(this.message)}&stack=${encodeURIComponent(this.stack)}&meta=${encodeURIComponent(JSON.stringify(this.metadata))}&origin=${encodeURIComponent(JSON.stringify((_a = this.origin) !== null && _a !== void 0 ? _a : null))}`;
    }
    toJSON(onlyData = false) {
        return {
            code: this.code,
            name: this.name,
            message: this.message,
            stack: onlyData ? undefined : this.stack,
            origin: onlyData ? undefined : this.origin,
            metadata: this.metadata,
            module: this.module,
            type: this.type,
        };
    }
}
class ExceptionRegistry {
    constructor(opts) {
        this._types = {};
        this._codeIndex = {};
        this._nameIndex = {};
        this._module = opts.module;
        if (!VALIDATE_MODULE.test(opts.module)) {
            throw _reg().raiseError(BUILT_IN_ERR_MALFORMED_MODULE, { 'module': opts.module });
        }
        for (const t in opts.types) {
            this.addType(t, opts.types[t]);
        }
    }
    getTypeNames() {
        return Object.keys(this._types);
    }
    addType(name, opts) {
        if (!VALIDATE_TYPE.exec(name)) {
            throw _reg().raiseError(BUILT_IN_ERR_MALFORMED_TYPE, { 'type': name });
        }
        if (this._types[name]) {
            throw _reg().raiseError(BUILT_IN_ERR_MALFORMED_TYPE, { 'type': name });
        }
        this._types[name] = {
            'indexFn': opts.index
        };
        return this;
    }
    get module() {
        return this._module;
    }
    raiseError(name, metadata, origin) {
        const ctor = this._nameIndex[name.toLowerCase()];
        // eslint-disable-next-line @typescript-eslint/unbound-method
        return new ctor(metadata, origin, this.raiseError);
    }
    has(id) {
        return !!(typeof id === 'string' ? this._nameIndex[id] : this._codeIndex[id]);
    }
    get(id) {
        var _a;
        return (_a = (typeof id === 'string' ? this._nameIndex[id] : this._codeIndex[id])) !== null && _a !== void 0 ? _a : null;
    }
    register(opts) {
        var _a;
        const type = this._types[opts.type];
        if (!type) {
            throw _reg().raiseError(BUILT_IN_ERR_TYPE_NOT_FOUND, Object.assign(Object.assign({}, opts), { 'module': this._module }));
        }
        if (!VALIDATE_NAME.test(opts.name)) {
            throw _reg().raiseError(BUILT_IN_ERR_MALFORMED_NAME, Object.assign(Object.assign({}, opts), { 'module': this._module }));
        }
        const code = (_a = opts.code) !== null && _a !== void 0 ? _a : this._types[opts.type].indexFn();
        if (this._nameIndex[opts.name]) {
            throw _reg().raiseError(BUILT_IN_ERR_DUP_EXCEPTION_NAME, Object.assign(Object.assign({}, opts), { 'module': this._module }));
        }
        if (this._codeIndex[code]) {
            throw _reg().raiseError(BUILT_IN_ERR_DUP_EXCEPTION_NAME, Object.assign(Object.assign({}, opts), { 'module': this._module }));
        }
        const ctor = (new Function('BaseException', `class ${opts.name} extends BaseException { } return ${opts.name};`))(BaseException);
        Object.defineProperties(ctor, {
            'message': {
                'writable': false,
                'configurable': false,
                'value': opts.message
            },
            'code': {
                'writable': false,
                'configurable': false,
                'value': code
            },
            'name': {
                'writable': false,
                'configurable': false,
                'value': opts.name
            },
            'module': {
                'writable': false,
                'configurable': false,
                'value': this.module
            },
            'type': {
                'writable': false,
                'configurable': false,
                'value': opts.type
            },
            'metadata': {
                'writable': false,
                'configurable': false,
                'value': opts.metadata
            }
        });
        Object.defineProperties(ctor.prototype, {
            'message': {
                'writable': false,
                'configurable': false,
                'value': opts.message
            },
            'code': {
                'writable': false,
                'configurable': false,
                'value': code
            },
            'name': {
                'writable': false,
                'configurable': false,
                'value': opts.name
            },
            'module': {
                'writable': false,
                'configurable': false,
                'value': this.module
            },
            'type': {
                'writable': false,
                'configurable': false,
                'value': opts.type
            }
        });
        this._nameIndex[opts.name] = ctor;
        this._codeIndex[code] = ctor;
        return ctor;
    }
    identify(e, type, name) {
        return e instanceof BaseException && (!type || (this._module === e.module && type === e.type && (!name || name === e.name)));
    }
    parse(e) {
        var _a, _b, _c, _d, _e;
        try {
            const url = new URL(e);
            if (url.protocol !== URL_PROTOCOL) {
                return null;
            }
            const [, type, eName] = url.pathname.split('/');
            if (!((_a = url.searchParams) === null || _a === void 0 ? void 0 : _a.has('code'))
                || !((_b = url.searchParams) === null || _b === void 0 ? void 0 : _b.has('msg'))
                || !((_c = url.searchParams) === null || _c === void 0 ? void 0 : _c.has('meta'))) {
                return null;
            }
            if (this._nameIndex[eName] && url.hostname === this._module) {
                return new this._nameIndex[eName](JSON.parse(url.searchParams.get('meta')), url.searchParams.has('origin') ? JSON.parse(url.searchParams.get('origin')) : null, (_d = url.searchParams.get('stack')) !== null && _d !== void 0 ? _d : '');
            }
            const ret = new BaseException(JSON.parse(url.searchParams.get('meta')), url.searchParams.has('origin') ? JSON.parse(url.searchParams.get('origin')) : null);
            ret.stack = (_e = url.searchParams.get('stack')) !== null && _e !== void 0 ? _e : '';
            ret.message = url.searchParams.get('msg');
            ret.module = url.hostname;
            ret.type = type;
            ret.name = eName;
            ret.code = parseInt(url.searchParams.get('code'));
            return ret;
        }
        catch (_f) {
            return null;
        }
    }
    fromJSON(j) {
        var _a, _b;
        if (this._nameIndex[j.name] && j.module === this._module) {
            return new this._nameIndex[j.name](j.metadata, j.origin, (_a = j.stack) !== null && _a !== void 0 ? _a : '');
        }
        const ret = new BaseException(j.metadata, j.origin);
        ret.stack = (_b = j.stack) !== null && _b !== void 0 ? _b : '';
        ret.message = j.message;
        ret.module = j.module;
        ret.type = j.type;
        ret.name = j.name;
        ret.code = j.code;
        return ret;
    }
    getDefinitions() {
        return Object.values(this._codeIndex).map((v) => ({
            'name': v.name,
            'code': v.code,
            'module': v.module,
            'message': v.message,
            'type': v.type,
            'metadata': Object.assign({}, v.metadata)
        }));
    }
}
const internalReg = new ExceptionRegistry({
    'module': 'exceptions.litert.org',
    'types': {
        [BUILT_IN_TYPE_NAME]: {
            'index': (function () {
                let index = -0xFFFFFFFF;
                return function () { return index++; };
            })(),
        }
    }
});
/**
 * Built-in exception: The type of new exception definition is not defined.
 */
exports.E_TYPE_NOT_FOUND = internalReg.register({
    'name': BUILT_IN_ERR_TYPE_NOT_FOUND,
    'message': 'The type of new exception definition is not defined.',
    'metadata': {},
    'type': BUILT_IN_TYPE_NAME
});
/**
 * Built-in exception: The type of new exception definition is malformed.
 */
exports.E_DUP_TYPE = internalReg.register({
    'name': BUILT_IN_ERR_DUP_TYPE,
    'message': 'The type of new exception definition already exists.',
    'metadata': {},
    'type': BUILT_IN_TYPE_NAME
});
/**
 * Built-in exception: The type of new exception definition is malformed.
 */
exports.E_MALFORMED_TYPE = internalReg.register({
    'name': BUILT_IN_ERR_MALFORMED_TYPE,
    'message': 'The type of new exception definition is malformed.',
    'metadata': {},
    'type': BUILT_IN_TYPE_NAME
});
/**
 * Built-in exception: The module name of new exception registry is malformed.
 */
exports.E_MALFORMED_MODULE = internalReg.register({
    'name': BUILT_IN_ERR_MALFORMED_MODULE,
    'message': 'The module name of new exception registry is malformed.',
    'metadata': {},
    'type': BUILT_IN_TYPE_NAME
});
/**
 * Built-in exception: The name of new exception is malformed.
 */
exports.E_MALFORMED_NAME = internalReg.register({
    'name': BUILT_IN_ERR_MALFORMED_NAME,
    'message': 'The name of new exception is malformed.',
    'metadata': {},
    'type': BUILT_IN_TYPE_NAME
});
/**
 * Built-in exception: The name of new exception has been used already.
 */
exports.E_DUP_EXCEPTION_NAME = internalReg.register({
    'name': BUILT_IN_ERR_DUP_EXCEPTION_NAME,
    'message': 'The name of new exception has been used already.',
    'metadata': {},
    'type': BUILT_IN_TYPE_NAME
});
/**
 * Built-in exception: The code of new exception has been used already.
 */
exports.E_DUP_EXCEPTION_CODE = internalReg.register({
    'name': BUILT_IN_ERR_DUP_EXCEPTION_CODE,
    'message': 'The code of new exception has been used already.',
    'metadata': {},
    'type': BUILT_IN_TYPE_NAME
});
// eslint-disable-next-line @typescript-eslint/naming-convention
function _reg() {
    return internalReg;
}
/**
 * Create a new exception registry object.
 * @param opts  The options of new registry.
 */
function createExceptionRegistry(opts) {
    return new ExceptionRegistry(opts);
}
exports.createExceptionRegistry = createExceptionRegistry;
/**
 * Helper function that identifies whether a value is a determined exception object.
 * @param e         The value to be identified.
 * @param type      The expected exception type, optional.
 * @param name      The expected exception name, optional.
 * @param module    The expected exception module name, optional.
 */
function identify(e, type, name, module) {
    return e instanceof BaseException && (!type || (type === e.type && (!name || name === e.name) && (!module || module === e.module)));
}
exports.identify = identify;
/**
 * Helper function that identifies whether a value is a determined exception object.
 * @param e             The value to be identified.
 * @param exceptionCtor The constructor of expected exception.
 */
function equals(e, exceptionCtor) {
    return e instanceof exceptionCtor || (e instanceof BaseException
        && exceptionCtor.type === e.type
        && exceptionCtor.name === e.name
        && exceptionCtor.module === e.module);
}
exports.equals = equals;
//# sourceMappingURL=Register.js.map