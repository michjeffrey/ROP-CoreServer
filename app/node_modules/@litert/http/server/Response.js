"use strict";
/*
   +----------------------------------------------------------------------+
   | LiteRT HTTP.js Library                                               |
   +----------------------------------------------------------------------+
   | Copyright (c) 2018 Fenying Studio                                    |
   +----------------------------------------------------------------------+
   | This source file is subject to version 2.0 of the Apache license,    |
   | that is bundled with this package in the file LICENSE, and is        |
   | available through the world-wide-web at the following url:           |
   | https://github.com/litert/http.js/blob/master/LICENSE                |
   +----------------------------------------------------------------------+
   | Authors: Angus Fenying <fenying@litert.org>                          |
   +----------------------------------------------------------------------+
 */
Object.defineProperty(exports, "__esModule", { value: true });
const http = require("http");
const Exception_1 = require("./Exception");
const Errors_1 = require("./Errors");
const Abstracts = require("./Abstract");
const http2 = require("http2");
const Internal_1 = require("./Internal");
function _extend(obj, name, fn) {
    obj[name] = fn;
}
function extend(name, fn) {
    _extend(http.ServerResponse.prototype, name, fn);
    _extend(http2.Http2ServerResponse.prototype, name, fn);
}
function extenDef(name, fn) {
    Object.defineProperty(http.ServerResponse.prototype, name, fn);
    Object.defineProperty(http2.Http2ServerResponse.prototype, name, fn);
}
extend("send", function (data) {
    if (this.finished) {
        throw new Exception_1.default(Errors_1.default.RESPONSE_ALREADY_CLOSED, "Response has been closed");
    }
    if (!this.headersSent) {
        this.setHeader("Content-Length", Buffer.byteLength(data));
    }
    this.end(data);
    return this;
});
extenDef("server", {
    get() {
        return this.connection.server[Internal_1.cServer];
    }
});
extend("redirect", function (target, statusCode = Abstracts.HTTPStatus.TEMPORARY_REDIRECT) {
    if (this.headersSent) {
        throw new Exception_1.default(Errors_1.default.HEADERS_ALREADY_SENT, "Response headers were already sent.");
    }
    this.writeHead(statusCode, { "Location": target });
    return this;
});
extend("sendJSON", function (data) {
    if (this.finished) {
        throw new Exception_1.default(Errors_1.default.RESPONSE_ALREADY_CLOSED, "Response has been closed");
    }
    data = JSON.stringify(data);
    if (!this.headersSent) {
        this.setHeader("Content-Type", "application/json");
        this.setHeader("Content-Length", Buffer.byteLength(data));
    }
    this.end(data);
    return this;
});
extend("setCookie", function (...args) {
    if (this.headersSent) {
        throw new Exception_1.default(Errors_1.default.HEADERS_ALREADY_SENT, "Response headers were already sent.");
    }
    let cookieText;
    if (args.length === 1) {
        cookieText = this.plugins["parser:cookies"].stringify(args[0]);
    }
    else {
        cookieText = this.plugins["parser:cookies"].stringify({
            "name": args[0],
            "value": args[1],
            "ttl": args[2],
            "httpOnly": args[3],
            "secureOnly": args[4],
            "path": args[5],
            "domain": args[6]
        });
    }
    if (this.hasHeader("Set-Cookie")) {
        let cookies = this.getHeaders()["set-cookie"];
        cookies.push(cookieText);
        this.setHeader("Set-Cookie", cookies);
    }
    else {
        this.setHeader("Set-Cookie", [cookieText]);
    }
    return this;
});
//# sourceMappingURL=Response.js.map