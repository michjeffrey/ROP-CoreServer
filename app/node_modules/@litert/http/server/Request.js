"use strict";
/*
   +----------------------------------------------------------------------+
   | LiteRT HTTP.js Library                                               |
   +----------------------------------------------------------------------+
   | Copyright (c) 2018 Fenying Studio                                    |
   +----------------------------------------------------------------------+
   | This source file is subject to version 2.0 of the Apache license,    |
   | that is bundled with this package in the file LICENSE, and is        |
   | available through the world-wide-web at the following url:           |
   | https://github.com/litert/http.js/blob/master/LICENSE                |
   +----------------------------------------------------------------------+
   | Authors: Angus Fenying <fenying@litert.org>                          |
   +----------------------------------------------------------------------+
 */
Object.defineProperty(exports, "__esModule", { value: true });
const http = require("http");
const http2 = require("http2");
const libUrl = require("url");
const queryString = require("querystring");
const Internal_1 = require("./Internal");
function _extend(obj, name, fn) {
    obj[name] = fn;
}
function extend(name, fn) {
    _extend(http.IncomingMessage.prototype, name, fn);
    _extend(http2.Http2ServerRequest.prototype, name, fn);
}
function extenDef(name, fn) {
    Object.defineProperty(http.IncomingMessage.prototype, name, fn);
    Object.defineProperty(http2.Http2ServerRequest.prototype, name, fn);
}
extend("getBodyAsJSON", function (maxLength = 0) {
    return this.getContent({
        "type": "json",
        "maxBytes": maxLength
    });
});
extend("getContent", function (opts) {
    if (!opts) {
        opts = {
            type: "auto"
        };
    }
    if (opts.type === "auto") {
        switch (this.getContentInfo().type) {
            case "application/json":
                opts.type = "json";
                break;
            case "application/x-www-form-urlencoded":
                opts.type = "urlencode";
                break;
            case "text/plain":
                opts.type = "string";
                break;
            case "application/xml":
            case "application/atom+xml":
                opts.type = "xml";
                break;
            case "application/base64":
                opts.type = "base64";
                break;
            case "multipart/form-data":
                opts.type = "multipart";
                break;
            default:
            case "application/plain":
            case "application/octed-stream":
                opts.type = "buffer";
                break;
        }
    }
    // @ts-ignore
    return this.connection.server[Internal_1.cServer]._opts.plugins[`parser:${opts.type}`].parse(this, opts);
});
extend("isDoNotTrack", function () {
    return this.headers["dnt"] ? true : false;
});
extenDef("server", {
    get() {
        delete this.server;
        Object.defineProperty(this, "server", {
            "value": this.connection.server[Internal_1.cServer]
        });
        return this.server;
    }
});
function _splitWeightString(val) {
    let ret = {};
    let tmp = val.replace(/\s/g, "").split(",").map((x) => x.split(";", 2));
    for (let lang of tmp) {
        if (!lang[1] || !lang[1].startsWith("q=")) {
            ret[lang[0].toLowerCase()] = 1;
        }
        else {
            ret[lang[0].toLowerCase()] = parseFloat(lang[1].substr(2));
        }
    }
    return ret;
}
extend("getAcceptableLanguages", function () {
    const raw = this.headers["accept-language"];
    return raw ? _splitWeightString(raw) : {};
});
extend("getAcceptableTypes", function () {
    const raw = this.headers["accept"];
    return raw ? _splitWeightString(raw) : {};
});
extend("getAcceptableEncodings", function () {
    const raw = this.headers["accept-encoding"];
    return raw ? _splitWeightString(raw) : {};
});
extend("getContentInfo", function () {
    let ret = {
        "type": "",
        "extras": {},
        "length": -1
    };
    let data;
    if (data = this.headers["content-length"]) {
        ret.length = parseInt(data);
    }
    if (data = this.headers["content-type"]) {
        data = data.toLowerCase().split(";").map((x) => x.trim());
        for (let el of data) {
            if (el.indexOf("=") > -1) {
                let kv = el.split("=", 2);
                // @ts-ignore
                ret.extras[kv[0]] = kv[1];
            }
            else {
                ret.type = el;
            }
        }
    }
    return ret;
});
extenDef("acceptableLanguages", {
    get() {
        delete this.acceptableLanguages;
        const raw = this.headers["accept-language"];
        Object.defineProperty(this, "acceptableLanguages", {
            "value": raw ? _splitWeightString(raw) : {}
        });
        return this.acceptableLanguages;
    }
});
extenDef("acceptableTypes", {
    get() {
        delete this.acceptableTypes;
        const raw = this.headers["accept"];
        Object.defineProperty(this, "acceptableTypes", {
            "value": raw ? _splitWeightString(raw) : {}
        });
        return this.acceptableTypes;
    }
});
extenDef("acceptableEncodings", {
    get() {
        delete this.acceptableEncodings;
        const raw = this.headers["accept-encoding"];
        Object.defineProperty(this, "acceptableEncodings", {
            "value": raw ? _splitWeightString(raw) : {}
        });
        return this.acceptableEncodings;
    }
});
extenDef("contentInfo", {
    get() {
        delete this.contentInfo;
        let ret = {
            "type": "",
            "extras": {},
            "length": -1
        };
        let data;
        if (data = this.headers["content-length"]) {
            ret.length = parseInt(data);
        }
        if (data = this.headers["content-type"]) {
            data = data.toLowerCase().split(";").map((x) => x.trim());
            for (let el of data) {
                if (el.indexOf("=") > -1) {
                    let kv = el.split("=", 2);
                    // @ts-ignore
                    ret.extras[kv[0]] = kv[1];
                }
                else {
                    ret.type = el;
                }
            }
        }
        Object.defineProperty(this, "contentInfo", {
            "value": ret
        });
        return this.contentInfo;
    }
});
extenDef("query", {
    get() {
        delete this.query;
        let url = libUrl.parse(this.url);
        if (typeof url.query === "string") {
            Object.defineProperty(this, "query", {
                "value": queryString.parse(url.query)
            });
        }
        else {
            Object.defineProperty(this, "query", {
                "value": url.query || {}
            });
        }
        return this.query;
    }
});
extend("getBody", async function (maxLength = 0) {
    return this.getContent({
        "type": "raw",
        maxBytes: maxLength
    });
});
extend("loadCookies", function () {
    if (this.isCookiesLoaded()) {
        return true;
    }
    let data = this.headers["cookie"];
    if (!data) {
        return false;
    }
    this.cookies = this.connection.server[Internal_1.cServer]._opts.plugins["parser:cookies"].parse(data);
    return true;
});
extend("isCookiesLoaded", function () {
    return this.cookies !== undefined;
});
//# sourceMappingURL=Request.js.map