"use strict";
/*
   +----------------------------------------------------------------------+
   | LiteRT HTTP.js Library                                               |
   +----------------------------------------------------------------------+
   | Copyright (c) 2018 Fenying Studio                                    |
   +----------------------------------------------------------------------+
   | This source file is subject to version 2.0 of the Apache license,    |
   | that is bundled with this package in the file LICENSE, and is        |
   | available through the world-wide-web at the following url:           |
   | https://github.com/litert/http.js/blob/master/LICENSE                |
   +----------------------------------------------------------------------+
   | Authors: Angus Fenying <fenying@litert.org>                          |
   +----------------------------------------------------------------------+
 */
Object.defineProperty(exports, "__esModule", { value: true });
const Abstracts = require("./Abstract");
const AbstractServer_1 = require("./AbstractServer");
const Exception_1 = require("./Exception");
const Errors_1 = require("./Errors");
const Internal_1 = require("./Internal");
class StandardDispatcher extends AbstractServer_1.default {
    constructor(opts) {
        super(opts);
        this._hosts = opts.hosts;
        this.__inheritPlugins();
        if (this._hosts["default"]) {
            this._default = this._hosts["default"];
            delete this._hosts["default"];
        }
        else {
            this._default = this._hosts[Object.keys(this._hosts)[0]];
        }
        this._registerSSL();
    }
    __inheritPlugins() {
        for (let prefix in this._hosts) {
            this._hosts[prefix].setMounted();
            for (let k in this._opts.plugins) {
                if (!this._hosts[prefix].hasPlugin(k)) {
                    this._hosts[prefix].setPlugin(k, 
                    // @ts-ignore
                    this._opts.plugins[k]);
                }
            }
        }
    }
    _isEnabledSSL() {
        if (this._opts.ssl) {
            return true;
        }
        let enabled = 0;
        let disabled = 0;
        for (let domain in this._hosts) {
            const host = this._hosts[domain];
            if (host.ssl) {
                if (disabled) {
                    throw new Exception_1.default(Errors_1.default.REQUIRE_SSL_CERTIFICATE, `The host of ${domain} lacks of SSL certificate.`);
                }
                enabled++;
            }
            else {
                if (enabled) {
                    throw new Exception_1.default(Errors_1.default.REQUIRE_SSL_CERTIFICATE, `One of the host lacks of SSL certificate.`);
                }
                disabled++;
            }
        }
        return enabled ? true : false;
    }
    _registerSSL() {
        if (!this._isEnabledSSL()) {
            return;
        }
        if (this._opts.port === Abstracts.DEFAULT_PORT) {
            this._opts.port = Abstracts.DEFAULT_SSL_PORT;
        }
        this._subSSL = {};
        if (this._default.ssl) {
            this._opts.ssl = this._default.ssl;
        }
        else {
            this._opts.ssl = this._hosts[Object.keys(this._hosts)[0]].ssl;
        }
        let minSSL = this._opts.ssl.minProtocolVersion ||
            Abstracts.DEFAULT_MIN_SSL_VERSION;
        for (let domain in this._hosts) {
            const sslVersion = this._hosts[domain].ssl.minProtocolVersion;
            this._subSSL[domain] = this._hosts[domain].ssl;
            if (sslVersion !== undefined && minSSL > sslVersion) {
                minSSL = sslVersion;
            }
        }
        this._opts.ssl.minProtocolVersion = minSSL;
    }
    async start() {
        await super.start();
        for (let domain in this._subSSL) {
            const item = this._subSSL[domain];
            this[Internal_1.kServer].addContext(domain, {
                "key": item.key,
                "cert": item.certificate
            });
        }
    }
    _getPEMType(val) {
        if (Array.isArray(val)) {
            return this._getPEMType(val[0]) + "[]";
        }
        else if (typeof val === "string") {
            return "string";
        }
        else if (val instanceof Buffer) {
            return "buffer";
        }
        return "unknown";
    }
    _getRequestCode() {
        return `    if (params["hosts"][request.hostDomain]) {

        const host = params["hosts"][request.hostDomain];

        request.connection.server[cServer] = host;

        request.plugins = response.plugins = host._opts.plugins;

        return host.__requestEntry(createContext(
            request,
            response
        )).catch(function(e) {
            server.emit("error", e);
        });
    }

    request.connection.server[cServer] = params["default"];

    request.plugins = response.plugins = params["default"]._opts.plugins;

    params["default"].__requestEntry(createContext(
        request,
        response
    )).catch(function(e) {
        server.emit("error", e);
    });`;
    }
    _getRequestParams() {
        return {
            "hosts": this._hosts,
            "default": this._default
        };
    }
    __requestEntry(context) {
        return Promise.resolve();
    }
}
exports.StandardDispatcher = StandardDispatcher;
exports.default = StandardDispatcher;
//# sourceMappingURL=StandardDispatcher.js.map