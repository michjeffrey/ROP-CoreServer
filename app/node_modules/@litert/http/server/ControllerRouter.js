"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/*
   +----------------------------------------------------------------------+
   | LiteRT HTTP.js Library                                               |
   +----------------------------------------------------------------------+
   | Copyright (c) 2018 Fenying Studio                                    |
   +----------------------------------------------------------------------+
   | This source file is subject to version 2.0 of the Apache license,    |
   | that is bundled with this package in the file LICENSE, and is        |
   | available through the world-wide-web at the following url:           |
   | https://github.com/litert/http.js/blob/master/LICENSE                |
   +----------------------------------------------------------------------+
   | Authors: Angus Fenying <fenying@litert.org>                          |
   +----------------------------------------------------------------------+
 */
require("reflect-metadata");
const Exception_1 = require("./Exception");
const Errors_1 = require("./Errors");
const StandardRouter_1 = require("./StandardRouter");
const fs = require("fs");
const pathUtils = require("path");
const META_KEY_RULE = "litert:http:router:rules";
const META_KEY_MIDDLEWARES = "litert:http:router:middlewares";
function Route(method, path, data) {
    return function (theClass, methodName) {
        let rules = Reflect.getMetadata(META_KEY_RULE, theClass, methodName) || [];
        if (Array.isArray(path)) {
            for (let item of path) {
                rules.push({
                    method,
                    path: item,
                    data
                });
            }
        }
        else {
            rules.push({
                method,
                path,
                data
            });
        }
        Reflect.defineMetadata(META_KEY_RULE, rules, theClass, methodName);
    };
}
exports.Route = Route;
function Get(path, data) {
    return Route("GET", path, data);
}
exports.Get = Get;
function Post(path, data) {
    return Route("POST", path, data);
}
exports.Post = Post;
function Put(path, data) {
    return Route("PUT", path, data);
}
exports.Put = Put;
function Patch(path, data) {
    return Route("PATCH", path, data);
}
exports.Patch = Patch;
function Delete(path, data) {
    return Route("DELETE", path, data);
}
exports.Delete = Delete;
function Head(path, data) {
    return Route("HEAD", path, data);
}
exports.Head = Head;
function Options(path, data) {
    return Route("OPTIONS", path, data);
}
exports.Options = Options;
function NotFound() {
    // @ts-ignore
    return Route("NOT_FOUND", "");
}
exports.NotFound = NotFound;
/**
 * Set and configure a static method as a middleware.
 */
exports.Middleare = function (...args) {
    return function (theClass, methodName) {
        let rules = Reflect.getMetadata(META_KEY_MIDDLEWARES, theClass, methodName) || [];
        rules.push(args);
        Reflect.defineMetadata(META_KEY_MIDDLEWARES, rules, theClass, methodName);
    };
};
class ControllerRouter extends StandardRouter_1.Router {
    loadControllers(root) {
        if (!fs.existsSync(root)) {
            throw new Exception_1.default(Errors_1.default.PATH_NOT_EXIST, "The path of controllers/middlewares doesn't exist.");
        }
        let items = fs.readdirSync(root);
        for (let item of items) {
            if (item[0] === ".") {
                continue;
            }
            if (item.endsWith(".js")) {
                let path = pathUtils.resolve(root, item);
                let cls = require(`${path.slice(0, -3)}`).default;
                for (let method of Object.getOwnPropertyNames(cls.prototype)) {
                    let data = Reflect.getMetadata(META_KEY_RULE, cls.prototype, method);
                    if (data === undefined) {
                        continue;
                    }
                    for (let rule of data) {
                        if (rule.method === "NOT_FOUND") {
                            this.notFound(function (ctx) {
                                let controller = new cls();
                                return controller[method](ctx);
                            });
                            continue;
                        }
                        this.register(rule.method, rule.path, function (ctx) {
                            let controller = new cls();
                            return controller[method](ctx);
                        }, rule.data);
                    }
                }
            }
            else if (fs.statSync(`${root}/${item}`).isDirectory()) {
                this.loadControllers(`${root}/${item}`);
            }
        }
        return this;
    }
    _loadMiddlewares(root) {
        let ret = [];
        if (Array.isArray(root)) {
            for (let path of root) {
                ret = ret.concat(this._loadMiddlewares(path));
            }
            return ret;
        }
        if (!fs.existsSync(root)) {
            throw new Exception_1.default(Errors_1.default.PATH_NOT_EXIST, "The path of controllers/middlewares doesn't exist.");
        }
        let items = fs.readdirSync(root);
        for (let item of items) {
            if (item[0] === ".") {
                continue;
            }
            if (!item.endsWith(".js")) {
                if (fs.statSync(`${root}/${item}`).isDirectory()) {
                    this.loadControllers(`${root}/${item}`);
                }
                continue;
            }
            let path = pathUtils.resolve(root, item);
            let cls = require(`${path.slice(0, -3)}`).default;
            for (let method of Object.getOwnPropertyNames(cls)) {
                let data = Reflect.getMetadata(META_KEY_MIDDLEWARES, cls, method);
                if (data === undefined) {
                    continue;
                }
                for (let rule of data) {
                    if (typeof rule[rule.length - 1] === "number") {
                        let priority = rule.pop();
                        ret.push({
                            "args": rule,
                            // @ts-ignore
                            "method": cls[method].bind(cls),
                            priority
                        });
                    }
                    else {
                        ret.push({
                            "args": rule,
                            // @ts-ignore
                            "method": cls[method].bind(cls),
                            "priority": 10
                        });
                    }
                }
            }
        }
        return ret;
    }
    loadMiddlewares(root) {
        let items = this._loadMiddlewares(root);
        items = items.sort((a, b) => a.priority - b.priority);
        for (let item of items) {
            this.use(...item.args, item.method);
        }
        return this;
    }
}
function createControllerRouter() {
    return new ControllerRouter();
}
exports.createControllerRouter = createControllerRouter;
//# sourceMappingURL=ControllerRouter.js.map