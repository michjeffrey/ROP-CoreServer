"use strict";
/*
   +----------------------------------------------------------------------+
   | LiteRT HTTP.js Library                                               |
   +----------------------------------------------------------------------+
   | Copyright (c) 2018 Fenying Studio                                    |
   +----------------------------------------------------------------------+
   | This source file is subject to version 2.0 of the Apache license,    |
   | that is bundled with this package in the file LICENSE, and is        |
   | available through the world-wide-web at the following url:           |
   | https://github.com/litert/http.js/blob/master/LICENSE                |
   +----------------------------------------------------------------------+
   | Authors: Angus Fenying <fenying@litert.org>                          |
   +----------------------------------------------------------------------+
 */
Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = require("@litert/core");
const Exception_1 = require("../Exception");
const Errors_1 = require("../Errors");
const kRawData = Symbol("rawData");
const kRawDataPromise = Symbol("rawDataPromise");
class RawParser {
    parse(request, opts) {
        if (request[kRawData]) {
            return Promise.resolve(request[kRawData]);
        }
        if (request[kRawDataPromise]) {
            return request[kRawDataPromise];
        }
        const maxLength = opts.maxBytes || 0;
        if (maxLength > 0
            && request.contentInfo.length > -1
            && request.contentInfo.length < maxLength) {
            return Promise.reject(new Exception_1.default(Errors_1.default.EXCEED_MAX_BODY_LENGTH, "The received body exceed max length restriction."));
        }
        let ret = new core_1.RawPromise();
        let buf = [];
        request[kRawDataPromise] = ret.promise;
        let onData;
        let onEnd;
        let onClose;
        let onTimeout;
        let doCleanEvents = function () {
            request.removeListener("data", onData);
            request.removeListener("end", onEnd);
            request.removeListener("close", onClose);
            request.removeListener("timeout", onTimeout);
        };
        if (maxLength) {
            let length = 0;
            onData = function (d) {
                length += d.byteLength;
                if (length > maxLength) {
                    doCleanEvents();
                    return ret.reject(new Exception_1.default(Errors_1.default.EXCEED_MAX_BODY_LENGTH, "The received body exceed max length restriction."));
                }
                buf.push(d);
            };
        }
        else {
            onData = (d) => {
                buf.push(d);
            };
        }
        onEnd = function () {
            request[kRawData] = Buffer.concat(buf);
            // @ts-ignore
            buf = undefined;
            doCleanEvents();
            ret.resolve(request[kRawData]);
        };
        onClose = function () {
            doCleanEvents();
            return ret.reject(new Exception_1.default(Errors_1.default.CONNECTION_CLOESD, "The connection was closed."));
        };
        onTimeout = function () {
            doCleanEvents();
            return ret.reject(new Exception_1.default(Errors_1.default.READING_DATA_TIMEOUT, "Timeout when reading data from request."));
        };
        request.on("data", onData)
            .once("end", onEnd)
            .once("close", onClose)
            .once("timeout", onTimeout);
        return ret.promise;
    }
}
function createRawParser() {
    return new RawParser();
}
exports.createRawParser = createRawParser;
//# sourceMappingURL=RawParser.js.map